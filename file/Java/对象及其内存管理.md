1. Java的内存管理分成了两个方面：内存分配和内存回收，这里的内存分配特指创建Java对象时JVM为该对象在堆空间内分配的内存空间，内存回收指的是当该Java对象失去引用，变成垃圾时，则回收失去引用的Java对象所占的内存，通过这种方式看起来在Java中可能不存在内存泄漏，但是实际上这是一种错觉，Java程序也会存在内存泄漏

2. Java中的变量大致上分成了两个部分：成员变量和局部变量，

   类体内定义的变量称为成员变量（field），如果使用static修饰成员变量，那么该成员变量又叫类变量，这表明这个成员属于类本身了，static不可以修饰局部变量

   **成员变量（包括类变量）会被放在堆空间中，栈空间中的是它的引用**

   **使用static修饰的成员变量是类变量，属于类本身，没有使用static修饰的成员变量是实例变量，属于该类的实例（也就是说实例变量属于对象）**

   局部变量又可以分成三个部分

   - 形参：在方法签名中定义的局部变量，由方法调用者为其赋值

   - 方法内部的局部变量，在方法内定义的局部变量，必须在方法内完成显式初始化，生命周期同方法
   - 代码块中的局部变量，在代码块内定义的局部变量，必须在代码块内完成显式初始化，生命周期同代码块

   **由于局部变量的作用时间很短，所以局部变量被放在栈空间中**

   ```java
   // 对于类变量和成员变量的区别，我想下面这段代码能够很好的表现出来
   public class demo {
       int a = b + 1;
       static int b = 2;
   }
   // 这段代码完全没有错误，因为变量b被static修饰，所以类加载的时候他就被初始化了，也就是说虽然他的位置在a后面，但是他是先被初始化的，因此在成员变量被初始化的时候能够引用他；而如果不用static修饰，那么就会有“非法前向引用”的错误
   ```

   我们知道JVM中一个类只能够对应一个class对象，所以对于类变量来说，每个类变量只需要一块内存空间。

   因为一个类能够创建多个Java对象，所以类每创建一次实例，就需要为实例变量分配一块内存空间，也就是说程序中有多少个实例，实例变量就需要多少块空间，如下实例

   ```java
   class Person {
       int age;
       String name;
       static int eyeNums;
   }
   
   public class demo{
       psvm(String[] args) {
           Person.eyeNums = 2;
           Person p1 = new Person();
           p1.age = 300;
           p1.name = "猪八戒";
           ...
           // 虽然我们也能够通过p1.eyeNnums得到eyeNums的值，看起来eyeNums是实例变量了，其实不然，在底层仍然是通过将p1转换成Person类去查找的
          Person.eyeNums = 3;     
       }
   }
   ```

   <img src="../../image/Java/image-20211210222820823.png" alt="image-20211210222820823" style="zoom:67%;" />

   从上图中也可以看出，类变量只会被分配一块空间


