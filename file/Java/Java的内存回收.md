## Java内存区域详解

如果没有特殊说明，，Java内存管理这一部分说的都是`HotSpot`虚拟机

>SUN的JDK版本从1.3.1开始运用`HotSpot`虚拟机， 2006年底开源，主要使用C++实现，JNI接口部分用C实现。
>
>`HotSpot`是较新的Java虚拟机，用来代替`JIT(Just in Time)`，可以大大提高Java运行的性能。
>
>Java原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。而`HotSpot`将常用的部分代码编译为本地(原生，native)代码，这样显着提高了性能。 `HotSpot` JVM 参数可以分为规则参数(standard options)和非规则参数(non-standard options)。



### 基本问题

- **介绍下 Java 内存区域（运行时数据区）**
- **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**
- **对象的访问定位的两种方式（句柄和直接指针两种方式）**

### 拓展问题

- **String 类和常量池**
- **8 种基本类型的包装类和常量池**





### Java内存区域（运行时内存区域）

Java虚拟机在运行Java程序的时候会把它管理的内存划分成若干个不同的数据区域，Java1.8和之前的版本略有不同

**Java1.8之前的版本**

<img src="../../image/Java/JVM运行时数据区域.150c33e1.png" alt="img" style="zoom:80%;" />

**Java1.8**

<img src="../../image/Java/Java运行时数据区域JDK1.8.37016205.png" alt="img" style="zoom:80%;" />

**<font color=red>可以看到，线程私有的内存空间是：程序计数器、本地方法栈、虚拟机栈</font>**

下面将分别介绍线程的私有内存空间、堆空间、方法区、运行时常量池和直接内存（元空间使用的就是直接内存）



#### 程序计数器

程序计数器是一块比较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，**字节码解释器工作时就是通过修改程序计数器的值来选取下一条需要执行的字节码所在的地址，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来执行**

> 为什么程序计数器必须是线程私有的呢？
>
> 这是为了线程发生切换之后能够恢复到切换之前的正确位置继续执行，所以每条线程都需要有自己的程序计数器，各个线程之间的程序计数器独立存储，互不影响，因此我们称这类存储区域为线程私有的内存

从上面的介绍中我们知道了<font color=red>程序计数器总共有两个作用</font>

- **字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制**，如：顺序执行、选择、循环、异常处理
- **在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道上次切换之前运行到哪里了，继续执行**



> 还有一点值得注意的是：程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建而创建，线程的消亡而消亡



#### Java虚拟机栈

**与程序计数器一样，Java虚拟机栈也是通过也是线程私有的，它的生命周期和线程一致，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的**

<font color=red>Java内存可以粗略的分为栈内存和堆内存，其中的栈就是指的现在所说的Java虚拟机栈，或者说是虚拟机栈中局部变量表部分（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息）</font>

**局部变量表中主要存放了编译期可知的各种数据类型**（8大基本数据类型：`int,float,double,long,short,byte,char,boolean`）**和对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

Java虚拟机栈中会出现两种错误：`OutOfMemoryError`和`StackOverFlowError`

- **`StackOverFlowError`：**若Java虚拟机栈的内存大小不允许动态扩展，那么当线程的请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就会抛出`StackOverFlowError`的错误
- **`OutOfMemoryError`：**Java虚拟机栈的内存可以动态扩展，如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`错误

> 注意，在HotSpot虚拟机中是不允许Java虚拟机栈动态扩展的，除了线程最开始申请栈空间时失败，否则在HotSpot中是不会出现`OutOfMemoryError`错误的



**问题：方法/函数是如何调用虚拟机栈中的内容的？**

Java栈可以类比数据结构中的栈，Java栈中保存的内容主要是栈帧，每一次函数调用都会有一个栈帧被压入虚拟机栈，每一个函数调用结束之后，都会有一个栈帧被弹出

Java方法有两种返回方式：

- return语句
- 抛出异常

不管哪种返回方式都会使得栈帧被弹出



#### 本地方法栈

本地方法栈和Java虚拟机栈的作用非常相似，他们两个的区别在于

- 虚拟机栈为虚拟机执行Java方法（字节码）服务
- 本地方法栈为虚拟机使用到的Native方法服务

> 因为HotSpot中是先把常用到的部分代码编译到本地（Native），所以在HotSpot中本地方法栈和Java虚拟机栈合二为一了

本地方法被执行的时候，在本地方法栈中会创建一个栈帧，栈帧中包含了局部变量表、操作数栈、动态链接、出口信息

方法执行完毕之后相应的栈帧也会被弹出栈并释放内存空间，也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误





#### 堆内存

Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都会在这里分配内存**

> Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与**逃逸分析技术**逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。 
>
> 在这里未逃逸出去的变量我感觉就是局部变量，我们在“对象及其内存管理”那一章中就已经知道了局部变量只会被放到栈空间中

Java的堆内存是垃圾收集器管理的主要区域，因此堆内存也被称作**GC堆（Garbage Collected Heap）**，从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以**Java堆还可以细分为：新生代和老年代，**更具体一些是：Eden空间、From Survivor、To Survivor空间等，**进一步划分的目的是为了更好地回收内存，或者更快地分配内存**



事实上，在Java7及之前版本中，Java堆空间分成了三个部分：新生代、老年代和永生代，如下图所示

![JVM堆内存结构-JDK7](../../image/Java/JVM堆内存结构-JDK7.7d9166eb.png)

Java8版本之后方法区被彻底删除了（HotSpot中的永生代也被删除了），取而代之的是元空间，元空间使用的是直接内存

![JVM堆内存结构-JDK8](../../image/Java/JVM堆内存结构-jdk8.919b9959.png)

**上图所示的Eden区、两个Survivor区都是属于新生代（为了便于区别，这两个Survivor区域按照顺序被命名为From Survivor和To Survivor），中间一层是老年代**

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> “Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。



**堆空间这里最容易出现的错误就是`OutOfMemoryError`错误，**并且出现这种错误之后的表现形式还会有几种，比如：

1. `java.lang.OutOfMemroyError: GC Overhead Limit Exceeded`：当JVM花了太多的时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误
2. `java.lang.OutOfMemoryError: Java heap space`：加入在创建新的对象时，堆内存中的空间不足以存放新创建的对象，就会引发此错误



#### 方法区

**方法区**和Java堆一样，是各个线程共享的内存区域，它**用于存储已被虚拟机加载**的类信息、常量、静态变量等、即时编译器编译后的代码等**数据**，因此**方法区也被称为永久代，**虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做**`Non-Heap(非堆)`**，目的应该是和Java堆区分开来

Java8之前永久代还没有被完全移除的时候，通常通过下面这些参数来调节方法区的大小

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```



> 方法区和永久代的关系如下：
>
> 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而**永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现**。也就是说，永久代是HotSpot虚拟机中的概念，永久代是一种实现，而方法区是Java虚拟机规范中的概念，是一种规范

**相对而言，GC在这个空间区域中是较少出现的，但并非数据进入方法区之后就“永久存在”了**

Java8之后，方法区（HotSpot的永久代）就被彻底移除了，取而代之的是元空间，元空间使用的是直接内存

元空间中的一些常用参数

```c
-XX:MetaspaceSize=N 		//设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N 		//设置 Metaspace 的最大大小
```

**为什么要使用元空间（MetaSpace）代替永久代（PermGen）呢**

1. 整个永久代有一个JVM本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍然有可能溢出，但是比原来出现的几率会更小

   > 当元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace` 

2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由`MaxPermSize`控制了，而由系统的实际可用空间来控制，这样能加载的类就更多了

3. 在JDK8中，合并`HotSpot`和`JRockit`的代码时，`JRockit`从来没有一个叫做永生代的东西，合并之后就没有必要额外设置这么一个永久代的地方了



#### 运行时常量池

运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表示（用于存放编译器生成的各种字面量和符号引用）

即然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出`OutOfMemoryError`错误

- Java1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时HotSpot虚拟机对方法区的实现成为永久代
- Java1.7字符串常量池被从方法区拿到了堆中，这里没有提高运行时常量池，也就是说除了字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是HotSpot中的永久代
- Java1.8HotSpot移除了永久代，用元空间取而代之，这时候字符串常量池还在堆中，运行时常量池还在方法区中，只不过方法区的实现由永久代变成了元空间



#### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。



### HotSpot虚拟机对象

#### 对象的创建

![Java创建对象的过程](../../image/Java/Java创建对象的过程.dbe33c41.png)

- **类加载检查，**虚拟机在遇到一条new指令时，首先会去检查这个指令的参数能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析过和初始化过。如果没有，那必须先执行相应的类加载过程

- **分配内存，**在类加载检查通过后，接下来虚拟机将为新生对象分配内存空间，**对象所需的内存大小在类加载完成后便可以确定**，为对象分配空间的任务等同于**把一块确定大小的内存从Java堆中划分出来**，**分配方式有“指针碰撞”和“空闲列表”两种，选择哪种分配方式是根据堆内存空间是否规整决定的，而堆内存空间是否规整又是由垃圾收集器是否带有压缩整理功能决定**

  > **<font color=red>内存分配的两种方式</font>**

  选择指针碰撞还是空闲列表是由堆内存空间是否规整决定的，而堆内存空间是否规整，取决于垃圾收集器的算法是“标记-清除”还是“标记-整理（也称作标记-压缩）”

  ![内存分配的两种方式](../../image/Java/内存分配的两种方式.9ecae4c9.png)

  > **<font color=red>内存分配并发问题</font>**

  在创建对象时有一个很重要的问题就是线程安全，因为在实际开发过程中，创建对象是一件很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全

  - **CAS + 失败重试：**CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
  - **TLAB：**为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB的内存已经用尽时，再采用上述的CAS进行内存分配

- **初始化零值，**内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型的零值（默认值）

- **设置对象头，**初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的的元数据信息、对象的哈希码、对象的GC分代年龄等信息，**这些信息放在对象头中**，另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式

- **执行init方法，**上面的4步工作都完成以后，从虚拟机的视角来看，一个新的对象已经产生，但是从Java程序的视角来看，对象创建才刚开始，`<init>`方法还没有执行，所有的字段都还是零值，所以一般来说，执行完`new`指令之后会接着执行`init`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来



#### 对象的内存布局

在HotSpot虚拟机中，对象在内存中的布局可以分成三块区域：**对象头、实例数据和对齐填充**

HotSpot虚拟机的对象头包括两部分信息，**第一部分是用来存储对象的自身运行时数据**（哈希码、GC分代年龄、锁状态标志等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容

**对齐填充部分不是必然存在的，也没有什么特殊的含义，仅仅是起到占位的作用**，因为HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全



#### 对象的访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象，**对象的访问方式由虚拟机实现而定**，目前主流的访问方式有**使用句柄**和**直接指针**两种

- **句柄：**如果使用的是句柄的话，那么Java堆中就会划分出一块空间来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息

  <img src="../../image/Java/对象的访问定位-使用句柄.53859387.png" alt="对象的访问定位-使用句柄" style="zoom:50%;" />

- **直接指针：**如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存放的直接就是对象的地址

  <img src="../../image/Java/对象的访问定位-直接指针.c3bbe790.png" alt="对象的访问定位-直接指针" style="zoom:50%;" />

**这两种对象访问方式各有优势，使用句柄访问的最大好处就是reference中存放的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改，使用直接指针访问方式的最大好处就是速度很快，因为他节省了一次指针定位的时间开销**



### 补充内容1：字符串常量池

> 常见的面试题：String类型的变量和常量做“+”运算时发生了什么？

```java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false

// 对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。
```

**对于编译期可以确定值的字符串，也就是常量字符串，JVM会将其加入到字符串常量池中**

字符串常量池是JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建

```java
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa==bb);// true
```

在Java1.7之前，字符串常量池被放在方法区中，在1.7之后，字符串常量池被移出到Java堆中

并且，**字符串常量拼接得到的字符串常量在编译阶段就会被放入到字符串常量池中**，这个得益于编译器的优化

在编译过程中，Javac编译器会进行一个**常量折叠**的代码优化，常量折叠会把常量表达式的值求出来作为常量嵌入到最终生成的代码中，这时Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎在即时编译器中进行）

能够进行常量折叠的情况：（**编译器在程序编译期就能够确定常量的值**）

- 基本数据类型(byte、boolean、short、char、int、float、long、double)以及字符串常量

- `final` 修饰的基本数据类型和字符串变量

- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）



**对象引用和“+”的字符串拼接方式实际上是通过`StringBuilder`调用`append()`方法实现的，拼接完成之后调用`toString()`得到一个`String`对象**

```java
// 比如上面例子中的String str4 = str1 + str2
// 实际上是 String str4 = new StringBuilder().append(str1).append(str2).toString();
```

**因此str4并不是字符串常量池中存在的对象，属于堆上的新对象**

![img](../../image/Java/字符串拼接-常量池.png)



我们在平时写代码的时候，应该避免多个字符串的拼接，如果字符串需要改变的话我们使用`StringBuilder`和`StringBuffer`

当`String`对象被`final`修饰的时候，可以让编译器把它当成常量来处理，如下例

```java
final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
```



如果编译器在运行期才能够知道变量的值，那么就无法进行如下，如下例子

```java
final String str1 = "str";
final String str2 = getStr();
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 在堆上创建的新的对象
System.out.println(c == d);// false
public static String getStr() {
      return "ing";
}
```



**<font color=red>只要使用new的方式创建对象，便需要创建新的对象</font>**

因此使用`String str = new String("aaa")`的时候会在堆内存中创建一个新的String对象

使用new创建对象的方式可以分为以下三步：

1. 在堆中创建一个字符串对象
2. 检查字符串常量池中是否有和new的字符串值相等的字符串常量
3. 如果没有的话则需要在字符串常量池中创建一个值相等的字符串常量，如果有的话就直接返回堆中的字符串实例对象地址

基于上述，我们可以下另外一个例子

```java
String str1 = "abcd";
String str2 = new String("abcd");
String str3 = new String("abcd");
System.out.println(str1==str2);
System.out.println(str2==str3);
// str1不用多说，“abcd”会被放入字符串常量池中，然后str1指向它在字符串常量池中的地址
// str2是使用new来创建的，所以它会在堆内存中创建一个新的对象
// str3同样是使用new来创建的，所以它也会在堆内存中创建一个新的对象
// 因此，输出的是两个false
```



**字符串常量池比较特殊，它的主要使用方法有两种**

1. 直接使用双引号声明出来String对象会直接存储在常量池中

2. 如果不是使用双引号声明出来的String对象，使用String提供的`intern()`方法也有相同的效果

   `String.intern()` 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 `String` 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中（这是在常量池中没有这个字符串的情况下，有这个字符串的话，直接使用常量池中字符串的引用），减少不必要的内存开销。

   ```java
           String s1 = "java";
           String s2 = s1.intern();
   
           String s3 = new String("java");  // 它的引用也是常量池中的，因为在他实例化之前，常量池中就已经存在java了,但是他的地址却是堆内存中地址
           String s4 = s3.intern();
   
           System.out.println(s1 == s2);  // true
           System.out.println(s3 == s4);  // false
           System.out.println(s1 == s3);  // false
           System.out.println(s1 == s4);  // true
           System.out.println(s2 == s3);  // false;
           System.out.println(s2 == s4);  // true
   ```



> 因此，我们就能够回答这个问题了：**<font color=red>String s1 = new String("abc");创建了几个对象？</font>**

**答案是一个或者两个**

- 如果字符串常量池中已经有`abc`这个字符串了，那么只需要在堆内存中创建一个字符串常量"abc"
- 如果字符串常量池中没有`abc`这个字符串的话，那么它将首先在字符串常量池中创建，然后再在堆空间中创建，因此创建总共2个字符串对象

```java
String s1 = new String("abc");// 堆内存的地址值
String s2 = "abc";
System.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。
System.out.println(s1.equals(s2));// 输出 true
```



### 补充内容2：8种基本数据类型的包装类和常量池

Java中除了两个浮点数类型的包装类`Float`和`Double`没有实现常量池技术，其余的6个均实现了常量池技术

`Byte,Integer,Short,Long`这4中包装类默认创建了数值`[-128, 127]`的相应类型的缓存数据，`Character`创建了数值在`[0,127]`范围的缓存数据，`Boolean`直接返回`True`或者`False`

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```



```java
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);
```

`Integer i1=40` 这一行代码会发生**<font color=red>装箱</font>**，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是常量池中的对象。而`Integer i1 = new Integer(40)` 会直接创建新的对象。

因此，答案是 `false` 。



**<font color=red>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</font>(这个在做题的时候已经碰到过了)**。



`Integer`类型之间比较更加丰富的一个例子

```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

System.out.println(i1 == i2);// true
System.out.println(i1 == i2 + i3);//true
System.out.println(i1 == i4);// false
System.out.println(i4 == i5);// false
System.out.println(i4 == i5 + i6);// true
System.out.println(40 == i5 + i6);// true
```

上面例子中我们知道`i1,i2,i3`都是常量池中的对象，`i4,i5,i6`都是堆内存中的对象

这里需要注意的是`i1 == i2 + i3`，不同于字符串常量池中的比较

```java
String a = "a";
String b = "b";
String ab = "ab";
System.out.println(ab == a + b);   // false
```

上面的`i1 == i2 + i3`返回的是true，我猜测应该是发生了拆箱操作

那`i4 == i5 + i6` 为什么是 true 呢？因为， **`i5` 和 `i6` 会进行自动拆箱操作，进行数值相加**，即 `i4 == 40` 。 `Integer` 对象无法与数值进行直接比较，所以 `i4` 自动拆箱转为 int 值 40，最终这条语句转为 `40 == 40` 进行数值比较。

所以Integer最终会变成数值之间的比较，而String中最终仍然是地址之间的比较











