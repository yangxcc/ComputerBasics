## 一条SQL语句在MySQL中的执行流程

### MySQL的基础架构

<img src="../../image/MySQL/image-20211210090241498.png" alt="image-20211210090241498" style="zoom:67%;" />

从整体上看，MySQL分为了Server层和存储引擎层

- Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图、函数等，还有一个通用日志模块binlog
- 存储引擎层：主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB自带redo log日志模块，现在最常用的存储引擎就是InnoDB。**它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**



> **Server层基本组件介绍**

1. **连接器，**主要和身份认证以及权限相关的功能相关，主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码、权限等操作，如果用户账号密码通过，连接器回到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，**后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的**

2. **查询缓存（MySQL8.0之后移除），**主要用来缓存我们执行的SELECT语句以及该语句的结果集。

   连接建立之后，执行查询语句的时候会先去查询缓存，MySQL会先校验这个sql是否执行过，以key-value的形式缓存在内存中，key是查询语句，value是结果集，如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。**当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。**

   MySQL查询不建议使用缓存，因为查询缓存失效的场景在实际情况中很常见，比如执行了一个更新整个表的语句，那么查询缓存就要全部被清空，对于不经常更新的表使用缓存还是可以的

   所以，在一般情况下我们是不会使用查询缓存的，**MySQL 8.0 版本后删除了缓存的功能，**官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。

   > 事实上，MySQL5.7中就已经将查询缓存（Query Cache）的默认值设置成了关闭，这是因为MySQL查询缓存的设计初衷是提高完全相同Query语句的响应速度，MySQL官方文档对查询缓存区域的定义是：这是一块比较独特的缓存区域，用来缓存特征Query的整个结果集信息，且共享给所有客户端，MySQL对查询语句进行hash计算后，把得到的hash值和Query查询的结果集对应存放在查询缓存区域中

   Query Cache的引入带来了一些问题，如下：

   - 对Query语句的要求过于严苛，Query语句发生的任何变化都会导致无法命中缓存
   - 查询缓存区域的淘汰策略过于严苛，对于表中的任何修改都会导致缓存失效，因此只有在读远大于写的情况下，Query Cache才能够发挥作用，对于读写平衡以及写多读少的场景下，Query Cache很难发挥作用
   - 当开启Query Cache选项后，如果查询请求没有命中Query Cache的话，MySQL会需要额外的性能开销去处理结果集，也就是将结果集写入到Query Cache中

   ```
   Assuming that scalability could be improved, the limiting factor of the query cache is that since only queries that hit the cache will see improvement; 
   it is unlikely to improve predictability of performance. For user facing systems, reducing the variability of performance is often more important than improving peak throughput.
   假设可扩展性可以得到改善，那么查询缓存的限制因素是，由于只有命中缓存的查询才能得到提高；它不太可能改善性能的可预测性。
   对于面向用户的系统来说，减少性能的可变性（保证性能稳定）往往比提高峰值吞吐量更重要。
   ```

   

3. **分析器，**MySQL语句没能命中缓存就会进入分析器，**分析器的作用就是用来分析这条SQL语句是干什么的**，分析器的执行会分成两个部分：

   - **词法分析**，看看这个SQL语句的目的是什么，一条SQL语句有多个字符串组成，首先要提取关键字，比如select，提出查询的表，提出字段名，提出查询条件等等，做完这些操作之后就会进入语法分析
   - **语法分析，**看看这个SQL语句是否正确，是否符合SQL语法

4. **优化器，**优化器的作用就是让SQL语句以它认为的最优执行方案就执行（有可能优化器认为的不是最优的），比如多个索引的时候应该如何选择索引，多表查询的时候怎么选择关联顺序等

   经过优化器之后，这条SQL语句怎么执行就已经定下来了

5. **执行器，**当确定了执行方案之后，MySQL就准备开始执行了，首先在执行之前会先校验用户的权限，如果没有权限那么会返回信息，如果有权限，就回去调用引擎的接口，返回接口的执行结果



**MySQL将结果返回给客户端是一个增量、逐步返回的过程，并不一定等到所有的结果集都查出来再返回**

这样做的好处有两个：

- 服务器端无需存储太多的结果，也就不会因为需要返回太多的结果而消耗太多的内存
- 这样的处理也能够让MySQL客户端第一时间获得返回的结果



### 语句分析

了解完MySQL的基础架构之后，那么一条MySQL语句到底是怎么执行的呢？

事实上，**SQL语句的执行要先看看这条SQL语句是查询语句还是更新语句**

#### 查询语句

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

根据上面对基础架构的描述，我们可以知道这条SQL语句的执行流程，如下：

- 首先检查该语句是否有执行权限，如果没有的话直接返回错误信息，如果有的话，先去查询缓存中查询，如果找的话直接返回结果，没有找到的话就继续向下执行

- 通过分析器进行词法分析，提取sql语句的关键元素，比如提交到上面这个查询语句的是select，提取到需要查询的表是tb_student，需要查询所有的列等，然后判断该sql语句语法是否正确，如果不正确的话，返回错误信息，如果正确的话继续向下执行

- 然后就是优化器确定执行方案，上面的sql语句，可以有两种执行方案

  ```
    a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
    b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。
  ```

  那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

- 进行权限校验，如果没有权限就会返回错误消息，如果有权限的话就会调用数据库引擎接口，返回引擎的执行结果



#### 更新语句

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

其实更新语句大致上的执行过程和查询语句差不多，只是执行更新操作肯定就要记录日志，MySQL自带的日志模块是binlog，所有的存储引擎都可以使用，而我们常用的InnoDB引擎还自带了一个日志模块redo log，我们就以InnoDB模式下来探讨这个语句的执行流程

- 先去查询“张三”这条记录，如果有缓存的话，也是会用到缓存
- 然后拿到查询的语句，将`age`改成19，然后调用API引擎接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log，并把redo log标记成prepare状态，然后告诉执行器，执行完成了可以随时提交
- 执行器收到通知之后记录binlog，然后调用引擎接口，提交redo log为提交状态
- 更新完成



> 疑问：用一个日志模块不行吗？

在InnoDB出来之前，存储引擎都只使用binlog这一个日志模块，这样会导致数据库没有crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。因为binlog中记录的是逻辑操作，SQL语句，而redo log是物理操作，能够保存事务执行之前的数据库“形状”



为了保证redo log和binlog可能导致的数据不一致现象，MySQL使用的是**两阶段提交**



### explain关键字

explain实际上是用来分析sql语句的一个工具

> 慢查询，其实就是某个查询语句的执行速度慢，这样很容易拖垮整个系统

![](../../image/MySQL/explain.jpg)

- `id`：表示select子句的操作顺序，id越大，优先级越高，越先被执行
- `select_type`：主要区分普通查询、联合查询、子查询等
  - `SIMPLE`：普通查询，简单的select查询
  - `UNION`：如果第二个select出现在union之后，则被标记为union
  - `PRIMARY`：查询中包含复杂的子部分，最外层会被标记为primary
  - `SUBQUERY`：在select或者where列表中包含了子查询
  - `DERIVED`：在from列表中包含的自查询衍生表
  - `UNION RESULT`：在union表中获取结果的select
- `table`：这一行数据来源于哪个表
- **`type`：查询使用了哪种类型**
  - `system`：一般是查询系统表时
  - `const`：表示通过索引一次就能找到
  - `eq_ref`：唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键索引和唯一键索引
  - `ref`：非唯一键索引，返回匹配某个单独值的所有行
  - `range`：只索引给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、<、>、in等的查询
  - `index`：表示使用到了索引
  - `all`：全表扫描
- `possible_keys`：可能应用在这张表上的索引，实际上不一定能用得到
- `key`：实际上使用到的索引，如果没用到为null
- `key_len`：表示索引中使用的字节数（可能使用的，不是实际的）
- `ref`：显示索引的哪一列被用到了
- `rows`：大致估算找出所需的记录要读取的行数
- `extra`：不适合在其他列显示，但十分重要的额外信息
  - `Using Index`：表示相应的select操作中使用了覆盖索引，避免访问表的数据行，效率高，如果同时出现了`using where`表明索引被用来执行索引键值查找
  - `Using Where`：表明使用了where进行过滤











