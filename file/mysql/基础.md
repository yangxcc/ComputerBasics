## 数据库的基础知识

### 基本概念

- 元组：元组是关系型数据库中的基本概念，关系是一张表，表中的每行（表中的每条记录）都是一个元组，每列都是一个属性
- 码：实体的属性叫做码，对应表中的列，码是能够唯一标识实体的属性
- 候选码：如果关系中的某一个属性或者属性组的值能够唯一标识一个元组，而其他任何的属性，属性组都不能够再标识，则称这个属性/属性组为候选码，例如在学生实体中，“学号”是能够唯一区分学生这一实体，如果“姓名 + 班级”也能够唯一区分这一实体，那么{学号}和{姓名，实体}都是候选码
- 主码：主码也叫主键，主键是从候选码中选出来的，**一个实体集中只能够有一个主码，但是可以有多个候选码**
- 外码：外码也叫外键，外键是某个关系中的一个属性，但是是另一个关系中的主键，则这个属性叫做外键
- 主属性：候选码中出现过的属性叫做主属性
- 非主属性：没有出现在候选码中的属性叫做非主属性



> 主键和外键有什么区别呢？

- 主键是用来唯一标识一个元组的，不能够重复而且不能有空值，一个表中只能够有一个主键
- 外键是用来和其他表建立联系用的，能够重复出现而且也可以为空，一个表中可以有多个外键



### 为什么不推荐使用外键和级联呢？

> 对于外键和级联，阿里巴巴的开发手册中说到：
>
> 【强制】不得使用外键和级联，一切外键的概念必须要在应用层完成
>
> 说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id是外键，如果更新学生表中的student_id，同时触发成绩表中student_id的更新，这就是级联更新，外键和级联更适用于单机低并发，不适用于分布式、高并发集群，级联更新是强阻塞，存在数据库更新风暴的风险，外键影响数据库插入的速度

当问到这个问题的时候，我们可以先说一下外键的缺点，再说一下外键的优点，然后最后总结来说一下，如下

答：外键存在以下问题：

- **外键增加了复杂性，**外键的主从关系是定的，假如哪天需求有变化，数据库中的这个字段不再需要和其他表有关联了就会产生很多麻烦，又比如在进行DELETE和UPDATE操作的时候必须考虑外键约束，这给开发和测试造成了很大麻烦
- **外键对分库分表不友好，**因为外键在分库分表的时候不会生效
- **增加了额外工作，**数据库在进行增删改时还需要增加外键的维护工作，但是我认为这一点不算是缺点，因为就算是没有外键，在应用层也需要做这一部分的工作

但是外键即然存在，那么它就有它的理由和优点，比如：

- **外键能够很好的保证数据一致性和完整性**
- **使用外键使得级联操作变得简单了，减少了代码量**

因此，我认为在低并发、而且不涉及分库分表是可以使用外键，没必要一棒子打死



### ER图

ER图又叫做实体-联系图，提供了实体、属性和关系的表示方法，用来描述现实世界业务场景的**概念模型**。实体之间的关系有一对一，一对多，多对多三种

<img src="D:/ComputerBasics/image/MySQL/image-20211206105319064.png" alt="image-20211206105319064" style="zoom:80%;" />



### 数据库范式

再说数据库范式之前，我们要先明确几个概念：

- **函数依赖**，如果在一张表中，属性（或属性组）X的值确定的情况下，一定能够确定出属性Y的值，那么就称Y依赖于X，记作`X->Y`
- **部分函数依赖**，如果X->Y，对于X的一个真子集X0，也有X0->Y，那么就说Y对X部分函数依赖，比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；
- **完全函数依赖**，在一个关系中，某个非主属性依赖于全部的主属性，比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
- **传递函数依赖**，假设X,Y,Z是U的不同属性子集，如果X确定Y，Y确定Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖于 X。传递函数依赖可能会导致数据冗余和异常，传递函数依赖的Y和Z通常属于同一个事务，因此可以将其合并放到一个表中，比如在关系R（学号，姓名，系名，系主任）中，学号->系名，系名->系主任，所以存在非主属性系主任对于学号的传递函数依赖



**第一范式（1NF）**

属性（对应于表中的字段）不能够再被分割，也就是这个字段只能是一个值，不能够再分为多个其他字段了，**1NF是所有关系型数据库的最基本要求**



**第二范式（2NF）**

在第一范式的基础上消除了非主属性对于码的部分函数依赖，要求数据库中数据库表中的非主键属性必须完全依赖于主键属性，避免存在部分依赖

<img src="D:/ComputerBasics/image/MySQL/image-20211206111454453.png" alt="image-20211206111454453" style="zoom:80%;" />



**第三范式（3NF）**

在第二范式的基础上消除了非主属性对于码的传递函数依赖，要求数据库中的非主属性不能依赖于其他非主键属性，避免存在传递依赖



**BC范式**

在满足3NF的基础上，要求关系中的每一个非主属性都完全依赖于全部主属性，避免存在其他非主属性之间的依赖关系



范式的目标是优化数据库的结构，减少数据冗余和数据更新异常，提高数据一致性和完整性。但需要注意，过度的规范化可能会导致复杂的表关联和降低查询性能，因此在实际应用中需要综合考虑具体需求和性能要求。



### 什么是存储过程

我们可以**把存储过程看成是一些SQL语句的集合，中间加了点逻辑控制语句**，存储过程在业务比较复杂的时候也是非常实用的，比如很多时候我们完成一个操作可能需要写一大串SQL语句，这时候我们可以写一个存储过程，这样也方便我们下次的调用，存储过程一旦调试通过之后就能够稳定运行，另外，存储过程的执行速度要比单纯的SQL语句块，因为存储过程是被预编译过的

> 注意，在阿里开发手册中，明确禁止使用存储过程，因为存储过程难以调试和扩展，而且可移植性差，还会消耗数据库资源



### drop，delete与truncate的区别

他们的区别主要体现在三个方面，用法不同，属于不同的数据库语言，执行速度不同

- **用法不同**

  - drop用在删除表的时候，`drop table 表名`删除整个表
  - truncate删除表中的全部数据，只是删除数据，不删除表结构，再插入数据的时候自增长 id 又从 1 开始`truncate table 表名`
  - delete用于删除表中的数据，如果使用`delete from table_name where ...`能够删除表中的某一行，如果不指定`where`，那么delete的用法和truncate一样

  > 指定了where条件的delete相当于单杀，truncate相当于团灭，drop是把电脑摔了



- **属于不同的数据库语言**

  - truncate和drop属于DDL（数据库定义语言），操作立即生效不能够回滚
  - delete属于DML（数据库操作语言），操作完以后不想提交事务还可以回滚，

  > delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。 

  

  > - DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。
  > - DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。



- **执行速度不同**

  drop > truncate > delete



### 数据库的设计通常分为哪几步

- **需求分析，**分析用户需求
- **概念结构设计**，E-R图
- **逻辑结构设计，**将ER图转换成数据表，从ER模型到关系模型的转换
- **物理结构设计，**主要是为设计的数据库选择合适的存储结构和存储路径
- **数据库实施，**包括编程、测试和试运行
- **数据库运行和维护，**系统的运行和数据库的日常维护





### 关系型数据库介绍

关系型数据库就是建立在关系模型基础上的数据库，关系模型表明了数据库中所存储的数据之间的关系，包括一对一、一对多、多对多

<img src="../../image/MySQL/image-20211212164255387.png" alt="image-20211212164255387" style="zoom:67%;" />

在关系型数据库中，我们的数据被存放在了各种表中，表中的每一行都存放着一条数据

大部分关系型数据库都是用SQL来操作数据库中的数据，并且大多数的关系型数据库都支持事务的ACID特性

**有哪些常见的关系型数据库呢？**

MySQL，PostgreSQL，Oracle，SQL Server，SELite（微信本地的聊天记录的存储就是用的SQLite）

**MySQL介绍**

MySQL是一种**关系型数据库**，主要用于持久化存储我们的系统中的一些数据比如用户信息

由于MySQL是**开源**免费的并且成熟的数据库，因此MySQL被大量使用在各种系统中，任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是**3306**。





### 存储引擎

查看MySQL提供的全部存储引擎

```mysql
show engines;
```

![image-20211212165226509](../../image/MySQL/image-20211212165226509.png)

从上图可以看出，MySQL当前默认的存储引擎是InnoDB，并且在MySQL5.7版本中只有InnoDB是支持事务的



查看MySQL当前默认的存储引擎

```mysql
mysql> show variables like %storage_engine%;
```

查看表的存储引擎

```mysql
show table status like "table_name";
```

![image-20211212165703112](../../image/MySQL/image-20211212165703112.png)





### MyISAM和InnoDB的区别

1. **是否支持行级锁**

   MyISAM只有表级锁，而InnoDB既支持行级锁又支持表级锁，默认行级锁，也就是说MyISAM一锁就锁住了整张表，所以在并发写的情况下，InnoDB性能要优越于MyISAM

2. **是否支持事务**

   MyISAM不支持事务，而InnoDB支持事务，所以InnoDB具备提交和回滚事务的能力

3. **是否支持数据库异常崩溃后的安全恢复**

   MyISAM不支持，InnoDB支持

   使用InnoDB的数据库在异常崩溃之后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复过程依赖于`redo log`

   > :rainbow:扩展一下
   >
   > - MySQL InnoDB引擎使用redo log（重做日志）来保证事务的持久性，因为redo log中保存的是对物理页的修改
   > - MySQL InnoDB引擎使用undo log（回滚日志）来保证事务的一致性
   > - MySQL InnoDB引擎通过MVCC，锁机制等手段来保证事务的隔离性（默认的隔离级别是Repeated Read）
   > - 保证了事务的原子性、隔离性、持久性之后才能够保证一致性

4. **是否支持外键**

   MyISAM不支持外键，而InnoDB支持

5. **是否支持MVCC**

   MyISAM不支持，InnoDB支持，因为MyISAM都不支持行级锁，也不支持事务，所以他没法支持MVCC

6. **只有InnoDB里的主键索引才是聚簇索引，MyISAM中的索引（无论是不是主键）都是非聚簇索引**



### 关于 MyISAM 和 InnoDB 的选择问题

大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。

《MySQL 高性能》上面有一句话这样写到:

> 不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。
>
> x
>
> :rainbow:但是我在看面经的时候发现有一个问题就是问“为什么MyISAM的查询速度要比InnoDB快”
>
> 对于这个问题要从聚簇索引和非聚簇索引的角度来回答
>
> 因为InnoDB中的主键索引是聚簇索引，也就是说索引和数据的位置放在一起，即树的叶节点中有完整的数据记录。但是当查询条件中不是使用的主键索引，而是使用的其他字段作为索引条件，那么就会产生回表现象，也就是说在其他字段作为索引的条件下，**辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录**，这是InnoDB里面的主键索引和辅助索引
>
> 而MyISAM中的主键索引和辅助索引虽然都是非聚簇索引，但是MyISAM索引结构的B+树中的**叶子节点上的data域存放的是相应数据记录的地址**，通过这个地址能够直接读取出数据记录，也就是说在**MyISAM中主键索引和辅助索引没有什么区别**，只需要一次就能够拿到想要的数据

一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。

因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。



### 锁机制和InnoDB锁算法

MyISAM和InnoDB存储引擎使用的锁：

- MyISAM使用的是表级锁（table-level locking）
- InnoDB可以使用表级锁，也支持行级锁（row-level locking），默认是行级锁

**表级锁和行级锁的对比**

- **表级锁：**MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB都支持表级锁
- **行级锁：**MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度最高，但是加锁的开销也最大，加锁慢，会出现死锁

InnoDB存储引擎的锁的算法有三种：

- `Record Lock`：记录锁，单个行记录上的锁
- `Gap Lock`：间隔锁，锁定一个范围，不包括记录本身
- `Next-key Lock`：record+gap临键锁，锁定一个范围，包括记录本身



### 查询缓存

在执行查询的时候，会先查询缓存，不过MySQL8.0就把查询缓存给移除了，因为这个功能不太实用

`my.cnf` 加入以下配置，重启 MySQL 开启查询缓存

```mysql
query_cache_type=1
query_cache_size=600000
```

MySQL 执行以下命令也可以开启查询缓存

```mysql
set global  query_cache_type=1;
set global  query_cache_size=600000;
```

<img src="../../image/MySQL/image-20211212183201295.png" alt="image-20211212183201295" style="zoom:67%;" />

**开启缓存后在<font color=red>同样的查询条件以及数据情况下</font>，会直接在缓存中返回结果**，这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。

通过上面，我们就能够发现几种缓存不命中的情况：

- 任何两个查询在任何字符上的不同都会导致缓存不命中
- 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL中的系统表，其查询结果也不会被缓存
- 缓存建立之后，MySQL的查询缓存会跟踪查询中涉及到的每个表，如果这些表（数据或者结构）发生变化，那么和这张表相关的所有缓存数据都将失效

缓存虽然能够提高查询性能，但是他也带来了额外的开销，每次查询之后都需要做一次缓存操作，失效后还需要销毁。因此开启查询缓存需要谨慎，尤其是对写密集的应用来说更应该如此，如果开启了，要注意合理控制缓存空间的大小，一般来说其大小设置为几十MB合适，此外，还可以通过`sql_cache`和`sql_no_cache`来控制某个查询语句是否需要缓存

```sql
select sql_no_cache count(*) from usr;
```



### 事务

**什么事务？**事务是逻辑上的一组操作，要么全执行，要么全不执行

>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：
>
>1. 将小明的余额减少 1000 元
>2. 将小红的余额增加 1000 元。
>
>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。
>
>这样就不会出现小明余额减少而小红的余额却并没有增加的情况。

**什么是数据库事务？**

我们平时如果没有特指**分布式事务**，往往就是指的是**数据库事务**，对于一个单体项目，往往就是数据库事务了

**那么数据库事务有什么作用呢？**

简单来说，数据库事务可以保证多个对数据库的操作（也就是SQL语句）构成一个逻辑上的整体，构成这个逻辑上的整体的这些数据库操作遵循：要么全执行，要么全不执行

```sql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```



另外，在关系型数据中的事务都具有ACID特性

**什么是ACID特性呢？**

- 原子性，事务最小的执行单位，不允许分割，事务的原子性确保了对数据库的操作要么全部执行，要么全都不执行
- 一致性，执行事务前后，数据保持一致，例如在转账业务中，无论事务是否成功，参与转账双方的钱数总额应该是不变得
- 隔离性，并发访问数据库时，一个用户的事务不被其他事务干扰，各并发事务之间数据库是独立的
- 持久性，一个事务被提交之后，他对数据库中数据的改变是持久的，数据库即使发生故障也不应该对其有任何影响



**数据事务的实现原理？**

我们这里以InnoDB存储引擎为例

- MySQL InnoDB引擎通过redo log来保证事务的持久性，通过undo log来实现事务的原子性
- MySQL InnoDB引擎通过MVCC，锁机制等来保证事务的隔离性
- 只有保证了原子性、隔离性和持久性，才能够保证一致性



**并发事务带来了哪些问题？**

- **脏读：**当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改：**指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读：** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读：**幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。



**不可重复读和幻读的区别**

不可重复读强调的是同一行记录中某列字段的修改，即同一事务多次读取到某一行中的结果是不一样的，而幻读强调的是记录的增加或者删除，比如多次读取同一记录发现记录增多或者减少了



**事务的隔离级别**

- READ UNCOMMITED**(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- READ COMMITED**(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- REPEATED READ**(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- SERILIZABLE**(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

> 从READ COMMITED开始就是通过MVCC来解决脏读和不可重复读了，在READ COMMITED隔离级别下，`m_ids`中包含了未提交的事务id，即这些事务对当前事务是不可见的，即其相应的操作对当前事务也是不可见的，但是由于在READ COMMITED级别下，每次select都会产生一个READ VIEW，所以仍然会有不可重复读的问题，但是在REPEATED READ隔离级别下，只会在第一次SELECT的时候产生一个Read View，解决了不可重复读问题

需要注意的是，MySQL的默认隔离级别是可重复读（REPEATED READ），在这种隔离级别下，仍然是不能够避免幻读，MySQL的解决方式是通过Next-key Lock来解决

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，<font color=red>但是你要知道的是 InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）** 并不会有任何性能损失。</font>

InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。

> 分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中，事务资源通常是关系型数据库系统，但是也可以是其他类型的资源，全局事务要求在其中参与的所有事务要么都提交，要么都回滚，这对事务原有的ACID又有了提高，另外，在分布式事务的情况下，必须要将MySQL InnoDB存储引擎的隔离级别设置为SERIALIZABLE





## 一条SQL语句在MySQL中的执行流程

### MySQL的基础架构

<img src="../../image/MySQL/image-20211210090241498.png" alt="image-20211210090241498" style="zoom:67%;" />

从整体上看，MySQL分为了Server层和存储引擎层

- Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图、函数等，还有一个通用日志模块binlog
- 存储引擎层：主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB自带redo log日志模块，现在最常用的存储引擎就是InnoDB。**它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

<img src="../../image/MySQL/mysql查询流程.webp" style="zoom:80%;" />

> **Server层基本组件介绍**

1. **连接器，**主要和客户端进行TCP三次握手以及身份认证、权限相关的功能相关，主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码、权限等操作，如果用户账号密码通过，连接器回到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，**后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的**

   *如何查看MySQL服务被多少个客户端连接？*可以执行`show processlist`命令，结果如下所示：

   <img src="../../image/MySQL/查看连接.webp" style="zoom:60%;" />

   可以看到`id=6`的用户的Command列的状态是sleep，这意味着用户在建立连接之后就没有再执行过任何的命令，也就是说这是一个空闲的连接，而且空闲时长是736秒了，但是空闲的连接不会一直空闲，*MySQL定义了空闲连接的最大空闲时长，是由`wait_timeout`参数控制的，默认是8小时*，如果超过了这个时间，连接器就会将这个空闲连接断开，此外，还可以通过`kill connection +id`的方式来主动断开，*MySQL服务支持的最大连接数由`max_connections`参数控制*，超过了这个值系统就会拒绝接下来的连接请求。

2. **查询缓存（MySQL8.0之后移除），**主要用来缓存我们执行的SELECT语句以及该语句的结果集。

   连接建立之后，执行查询语句的时候会先去查询缓存，MySQL会先校验这个sql是否执行过，以key-value的形式缓存在内存中，key是查询语句，value是结果集，如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。**当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。**

   MySQL查询不建议使用缓存，因为查询缓存失效的场景在实际情况中很常见，比如执行了一个更新整个表的语句，那么查询缓存就要全部被清空，对于不经常更新的表使用缓存还是可以的

   所以，在一般情况下我们是不会使用查询缓存的，**MySQL 8.0 版本后删除了缓存的功能，**官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。

   > 事实上，MySQL5.7中就已经将查询缓存（Query Cache）的默认值设置成了关闭，这是因为MySQL查询缓存的设计初衷是提高完全相同Query语句的响应速度，MySQL官方文档对查询缓存区域的定义是：这是一块比较独特的缓存区域，用来缓存特征Query的整个结果集信息，且共享给所有客户端，MySQL对查询语句进行hash计算后，把得到的hash值和Query查询的结果集对应存放在查询缓存区域中

   Query Cache的引入带来了一些问题，如下：

   - 对Query语句的要求过于严苛，Query语句发生的任何变化都会导致无法命中缓存
   - 查询缓存区域的淘汰策略过于严苛，对于表中的任何修改都会导致缓存失效，因此只有在读远大于写的情况下，Query Cache才能够发挥作用，对于读写平衡以及写多读少的场景下，Query Cache很难发挥作用
   - 当开启Query Cache选项后，如果查询请求没有命中Query Cache的话，MySQL会需要额外的性能开销去处理结果集，也就是将结果集写入到Query Cache中

   ```
   Assuming that scalability could be improved, the limiting factor of the query cache is that since only queries that hit the cache will see improvement; 
   it is unlikely to improve predictability of performance. For user facing systems, reducing the variability of performance is often more important than improving peak throughput.
   假设可扩展性可以得到改善，那么查询缓存的限制因素是，由于只有命中缓存的查询才能得到提高；它不太可能改善性能的可预测性。
   对于面向用户的系统来说，减少性能的可变性（保证性能稳定）往往比提高峰值吞吐量更重要。
   ```

   > **注：**这里说的查询缓存是在server层的，和InnoDB引擎中的buffer pool是不同的概念

3. **分析器，**MySQL语句没能命中缓存就会进入分析器，**分析器的作用就是用来分析这条SQL语句是干什么的**，分析器的执行会分成两个部分：

   - **词法分析**，看看这个SQL语句的目的是什么，一条SQL语句有多个字符串组成，首先要提取关键字，比如select，提出查询的表，提出字段名，提出查询条件等等，做完这些操作之后就会进入语法分析
   - **语法分析，**看看这个SQL语句是否正确，是否符合SQL语法

   > **注：**表不存在或者字符不存在并不是在分析器里做的

4. 解析完SQL就进入到了执行SQL阶段，分成了三个步骤，**`prepare`阶段**、`optimize`阶段、`execute`阶段，在预处理阶段，主要会做两部分的工作，*检查SQL查询语句中的表或字段是否存在、将`select *`中的`*`扩展为表上所有的列*

5. **优化器，**优化器的作用就是让SQL语句以它认为的最优执行方案就执行（有可能优化器认为的不是最优的），比如多个索引的时候应该如何选择索引，多表查询的时候怎么选择关联顺序等

   经过优化器之后，这条SQL语句怎么执行就已经定下来了

6. **执行器，**当确定了执行方案之后，MySQL就准备开始执行了，首先在执行之前会先校验用户的权限，如果没有权限那么会返回信息，如果有权限，就回去调用引擎的接口，返回接口的执行结果

当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。

**具体更新一条记录 `UPDATE t_user SET name = 'xiaolin' WHERE id = 1;` 的流程如下:**

1. 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：
   - 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；
   - 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。
2. 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：
   - 如果一样的话就不进行后续更新流程；
   - 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 `InnoDB` 层，让 `InnoDB` 真正的执行更新记录的操作；
3. 开启事务， **InnoDB 层更新记录前，首先要记录相应的 undo log**，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过*在内存修改该 Undo 页面后，需要记录对应的 redo log*。
4. InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 **WAL 技术**，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。
5. 至此，一条记录更新完了。
6. 在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。
7. 事务提交，剩下的就是「两阶段提交」的事情了





**MySQL将结果返回给客户端是一个增量、逐步返回的过程，并不一定等到所有的结果集都查出来再返回**

这样做的好处有两个：

- 服务器端无需存储太多的结果，也就不会因为需要返回太多的结果而消耗太多的内存
- 这样的处理也能够让MySQL客户端第一时间获得返回的结果



### 语句分析

了解完MySQL的基础架构之后，那么一条MySQL语句到底是怎么执行的呢？

事实上，**SQL语句的执行要先看看这条SQL语句是查询语句还是更新语句**

#### 查询语句

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

根据上面对基础架构的描述，我们可以知道这条SQL语句的执行流程，如下：

- 首先检查该语句是否有执行权限，如果没有的话直接返回错误信息，如果有的话，先去查询缓存中查询，如果找的话直接返回结果，没有找到的话就继续向下执行

- 通过分析器进行词法分析，提取sql语句的关键元素，比如提交到上面这个查询语句的是select，提取到需要查询的表是tb_student，需要查询所有的列等，然后判断该sql语句语法是否正确，如果不正确的话，返回错误信息，如果正确的话继续向下执行

- 然后就是优化器确定执行方案，上面的sql语句，可以有两种执行方案

  ```
    a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
    b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。
  ```

  那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

- 进行权限校验，如果没有权限就会返回错误消息，如果有权限的话就会调用数据库引擎接口，返回引擎的执行结果



#### 更新语句

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

其实更新语句大致上的执行过程和查询语句差不多，只是执行更新操作肯定就要记录日志，MySQL自带的日志模块是binlog，所有的存储引擎都可以使用，而我们常用的InnoDB引擎还自带了一个日志模块redo log，我们就以InnoDB模式下来探讨这个语句的执行流程

- 先去查询“张三”这条记录，如果有缓存的话，也是会用到缓存
- 然后拿到查询的语句，将`age`改成19，然后调用API引擎接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log，并把redo log标记成prepare状态，然后告诉执行器，执行完成了可以随时提交
- 执行器收到通知之后记录binlog，然后调用引擎接口，提交redo log为提交状态
- 更新完成



> 疑问：用一个日志模块不行吗？

在InnoDB出来之前，存储引擎都只使用binlog这一个日志模块，这样会导致数据库没有crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。因为binlog中记录的是逻辑操作，SQL语句，而redo log是物理操作，能够保存事务执行之前的数据库“形状”



为了保证redo log和binlog可能导致的数据不一致现象，MySQL使用的是**两阶段提交**



### explain关键字

explain实际上是用来分析sql语句的一个工具

> 慢查询，其实就是某个查询语句的执行速度慢，这样很容易拖垮整个系统

![](../../image/MySQL/explain.jpg)

- `id`：表示select子句的操作顺序，id越大，优先级越高，越先被执行
- `select_type`：主要区分普通查询、联合查询、子查询等
  - `SIMPLE`：普通查询，简单的select查询
  - `UNION`：如果第二个select出现在union之后，则被标记为union
  - `PRIMARY`：查询中包含复杂的子部分，最外层会被标记为primary
  - `SUBQUERY`：在select或者where列表中包含了子查询
  - `DERIVED`：在from列表中包含的自查询衍生表
  - `UNION RESULT`：在union表中获取结果的select
- `table`：这一行数据来源于哪个表
- **`type`：查询使用了哪种类型**
  - `system`：一般是查询系统表时
  - `const`：表示通过索引一次就能找到
  - `eq_ref`：唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键索引和唯一键索引
  - `ref`：非唯一键索引，返回匹配某个单独值的所有行
  - `range`：只索引给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、<、>、in等的查询
  - `index`：表示使用到了索引
  - `all`：全表扫描
- `possible_keys`：可能应用在这张表上的索引，实际上不一定能用得到
- `key`：实际上使用到的索引，如果没用到为null
- `key_len`：表示索引中使用的字节数（可能使用的，不是实际的）
- `ref`：显示索引的哪一列被用到了
- `rows`：大致估算找出所需的记录要读取的行数
- `extra`：不适合在其他列显示，但十分重要的额外信息
  - `Using Index`：表示相应的select操作中使用了覆盖索引，避免访问表的数据行，效率高，如果同时出现了`using where`表明索引被用来执行索引键值查找
  - `Using Where`：表明使用了where进行过滤
  - `Using Index Condition`：表明使用了索引下推



## MySQL的一行记录是怎么存储的

### MySQL的数据存放格式

通过命令查看MySQL数据库的文件存放在哪个目录下面：

```shell
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```

因此，我们每创建一个数据库，都会在`/var/lib/mysql`路径下创建一个以数据库名为名称的文件夹，比如，我这里有一个名为 `my_test` 的 `database`，该 `database` 里有一张名为 `t_order` 数据库表。

```shell
[root@xiaolin ~]#ls /var/lib/mysql/my_test
db.opt  
t_order.frm  
t_order.ibd
```

- `db.opt`，用来存储当前数据库的默认字符集和字符校验规则。
- `t_order.frm` ，`t_order` 的**表结构**会保存在这个文件。在 MySQL 中建立一张表都会生成一个`.frm` 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- `t_order.ibd`，`t_order` 的**表数据**会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在**独占表空间文件**（文件名：表名字.ibd）。这个行为是由参数 `innodb_file_per_table` 控制的，若设置了参数` innodb_file_per_table` 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。



下面我们来看一下**独占表空间文件的结构**是什么样的

表空间是由段（Segment）、区（Extent）、页（Page）、行（Row）组成的

- **数据库表中的记录是按行进行存放的**，每个记录根据不同的行格式，有不同的存储结构

- 记录是按照行的格式进行存放的，但是数据库却不是以行为基本单位进行读写的，因为一次只能读写一行数据，效率太低了，**`InnoDB`的数据是按照页为单位来进行读写的**，也就是说，当需要读一条记录的时候，并不是将这行记录从磁盘中读取出来，而是以页为单位，将其整体读入内存。

  默认每个页的大小为16KB，也就是最多能够保证16KB的连续存储空间

- 我们知道InnoDB引擎是用B+树来组织数据的，B+树中的每一层都是通过双向链表连接起来的，如果是以页为单位来分配内存，那么链表中两个相邻的页的物理位置不是连续的，可能距离非常远，因此在磁盘查询时会有大量的随机IO，随机IO是非常慢的，解决这个问题的方法很朴素，就是将链表中相邻的页也相邻，这样就能够使用顺序IO了。具体地，**在表中数据量大的时候，为某个索引分配空间的时候就不再需要按照页为单位分配了，而是按照区为单位分配，每个区的大小是1M，对于16KB的页来说，连续的64个页会被划分成一个区，这样就使得链表中相邻的页物理位置也相邻了，也就能够执行顺序IO了**

- 表空间是由各个段组成的，段一般分为数据段、索引段和回滚段等。





### InnoDB的行格式

所谓行格式（row format），就是一条记录的存储结构

InnoDB提供了四种行格式，分别是`Redundant`,`Compact`,`Dynamic`和`Compressed`行格式

- `Redundant`是一种很古老的行格式了，MySQL 5.0版本之前用的行格式，现在基本上没人用了
- 由于`Redundant`不是一种紧凑的行格式，所以MySQL 5.0之后就引入了`Compact`行记录存储方式，`Compact`是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从MySQL 5.1版本开始，行格式被默认设置为`Compact`
- `Dynamic` 和` Compressed `两个都是紧凑的行格式，它们的行格式都和` Compact `差不多，因为都是基于` Compact` 改进一点东西。从 MySQL 5.7 版本之后，默认使用` Dynamic `行格式



#### Compact格式

<img src="../../image/MySQL/COMPACT.drawio.webp" style="zoom:60%;" />

一条完整的记录分成了两部分：记录的额外信息 和 记录的真实数据

##### 额外信息

记录的额外信息包含三个部分：变长字段长度列表、NULL值列表、记录头信息

- **<font color=red>变长字段长度列表：</font>**varchar是变长字符串，实际存储数据的大小不固定，所以在存储数据时也要把数据占用的大小存起来，存到 变长字段长度列表中，读取数据的时候才能够根据这个变长字段长度列表去读取对应长度的数据，其他TEXT、BLOB等变长字段也是这么实现的

  这里有一个数据表

  ```sql
  CREATE TABLE `t_user` (
    `id` int(11) NOT NULL,
    `name` VARCHAR(20) DEFAULT NULL,
    `phone` VARCHAR(20) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
  ```

  现在表里有三条数据

  ![](../../image/MySQL/数据库表demo.png)

  先来看第一条记录：

  - name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；
  - phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；
  - age 列和 id 列不是变长字段，所以这里不用管。

  **这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放**，如下所示：

  ![](../../image/MySQL/demo1.png)

  第三行数据中的phone值是NULL，NULL是不会存放在行格式中记录的真实数据部分的，所以，变长字段长度列表里不需要保存值为NULL的变长字段的长度

  那么，**为什么变长字段长度列表中的信息需要逆序存放呢？**

  变长字段长度列表中的信息之所以要逆序存放，**是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个CPU Cache Line中**，这样就可以提高CPU Cache Line的缓存命中率

  需要注意的是*，不是所有的数据库表中的行格式有变长字段长度列表，当数据库表中没有变长字段的时候*，比如全部都是int类型的字段，这时候表里的行格式就不会有变长字段长度列表了，因为没必要，不如去掉以节省空间。

- **<font color=red>NULL值列表：</font>**表中的某些列可能会存储NULL值，如果把这些NULL值都放到记录的真实数据中会比较浪费空间，所以Compact行格式把这些值为NULL的列存储到NULL值列表中

  如果存在允许NULL值的列，则每个列对应一个二进制位，二进制位按照列的顺序逆序排列

  - 二进制位的值是1时，代表该列的值为NULL
  - 二进制位的值是0时，代表该列的值不为NULL

  另外，NULL值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补0

  仍然以上面表中的三条数据为例：

  依次为：

  <img src="../../image/MySQL/demo2.png" style="zoom:50%;" /><img src="../../image/MySQL/demo3.png" style="zoom:50%;" /> <img src="../../image/MySQL/demo4.png" style="zoom:50%;" />

十六进制依次为：0x00，0x04，0x06

综合前面的变长字段长度列表，三行数据的行格式如下：

<img src="../../image/MySQL/null值列表5.webp" style="zoom:80%;" />

注意：每个数据库表中的行格式不一定有NULL值列表，当数据库表中的字段都定义成NOT NULL的时候，这时表中的行格式就不会有NULL值列表了

而且NULL值列表的长度不是固定的1字节，比如有9个NULL 的字段，那么NULL值列表的长度是2字节。

- **<font color=red>记录头信息</font>**中的内容比较多，如下：
  - `delete_mask` ：标识此条数据是否被删除。从这里可以知道，我们执行 `detele` 删除记录的时候，并不会真正的删除记录，只是将这个记录的 `delete_mask` 标记为 1。
  - `next_record`：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
  - `record_type`：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录



##### 记录的真实数据

<img src="../../image/MySQL/记录的真实数据.webp" style="zoom:80%;" />

记录的真实数据除了我们定义的字段外，还有三个隐藏字段：

- `row_id`，不是必需的，占用6个字节，如果我们创建表时没有指定主键，也没有唯一约束，那么InnoDB就会为记录添加`row_id`字段
- `trx_id`，必需的，占用6个字节，表示这个数据是由哪个事务生成的
- `roll_ptr`，必需的，占用7个字节，记录上一个版本的指针

其中，`trx_id`和`roll_ptr`是MVCC实现所依赖的。



## 数据页的结构

我们前面说到了MySQL中的记录是一行行的被放在数据页中，那么这些记录是如何被组织起来的呢？

事实上，**数据页中的记录按照主键顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最长的情况下需要遍历链表上的所有结点才能够完成检索。因此，数据页中有一个**页目录**，起到记录的索引作用，如下所示：

<img src="../../image/MySQL/数据页的结构.webp" style="zoom:80%;" />

页目录创建的过程如下：

1. 将所有的记录划分成几个组，这些记录包含最小记录和最大记录，但是不包括标记为”已删除“的记录
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned字段（图中的粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为”槽“（slot），每个槽相当于指针指向了不同组的最后一个记录

可以看到，**页目录就是由多个槽组成的，槽相当于分组记录的索引，然后，因为记录是按照主键值从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽，定位到槽以后，再遍历槽内的所有记录，找到对应的记录**，而无需从最小记录开始遍历整个页中的记录链表



自然的，当有大量数据的时候，我们需要多个数据页，这时我们需要考虑如何建立合适的索引，才能方便定位记录所在的页，为了解决这个问题，InnoDB采用了B+树作为索引，磁盘的IO操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于使用”矮胖“的B+树作为索引，B+树中的每个节点都是一个数据页，如下：

![](../../image/MySQL/B+树组织数据页.webp)

只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。



## Varchar(n)中n的最大取值

**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。也就是一行的总长度不能超过65535个字节

此外，`varchar(n)`中的n指的是字符的个数，而不是字节大小。

要算 `varchar(n)` 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 `ascii` 字符集， 1 个字符占用 1 字节，那么` varchar(100) `意味着最大能允许存储 100 字节的数据。

### 单字段的情况

假设数据库只有一个`varchar(n)`类型的列且字符集是`ascii`，在这种情况下，`varchar(n)`的最大取值是多少？

如果定义了一个`varchar(65535)`的字段，字符集为`ascii`的数据库表，如下：

```mysql
CREATE TABLE test ( 
`name` VARCHAR(65535)  NULL
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

执行上面的建表命令，会出现下面的错误：

<img src="../../image/MySQL/error.webp" style="zoom:80%;" />

报错信息中有提示：**一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead**

storage overhead其实就是变长字段长度列表和NULL值列表，也就是说，**一行数据的最大字节数是65535，其中也包含了变长字段长度列表和NULL值列表所占用的字节数的**，所以我们在算`varchar(n)`中n最大值时，需要减去storage overhead的长度的

这是因为我们储存`varchar(n)`类型的数据时，其实是分成了三部分来存储的

- 真实数据

- 变长字段长度：真实数据占用的字节数
- NULL标识，如果不允许为NULL，这部分不需要

因为，在建表时字段是允许为NULL的，所以会用1字节来表示NULL值列表，而「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：

- 条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；
- 条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；

我们这里字段类型是 `varchar(65535) `，字符集是 `ascii`，所以代表着变长字段允许存储的最大字节数是` 65535`，符合条件二，所以会用 2 字节来表示「变长字段长度」

**因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节**。

所以，当我们把n的值调整为65532后，发现建表成功了

![](../../image/MySQL/65532.webp)



注意：我们上面是针对字符集为`ascii`的情况，如果采用的是`UTF-8`，n的计算方式就会发生变化了

因为在`UTF-8`字符集下，一个字符最多需要三个字节，`varchar(n)`中n的最大取值就是`65532/3=21844`



### 多字段的情况

如果有多个字段，那么就要保证**所有字段的长度+变长字段长度列表所占用的字节数+NULL值列表所占用的字节数 <= 65535**

![](../../image/MySQL/1.webp)



### 行溢出后，MySQL是如何处理的

MySQL中磁盘和内存交互的基本单位是页，一个页的大小一般是16KB，也就是16384字节，而一个varchar类型的字段最多就能够存储65532字节，一些大对象比如TEXT，BLOB可能存储更多的数据，这时**一个页可能就存不了一条记录了，这个时候就会发生行溢出，多的数据就会存到另外的溢出页中。**

一般情况下，InnoDB的数据都是存放在数据页中的，但是当发生了行溢出之后，溢出的数据会被存放到溢出页上，如下：

<img src="../../image/MySQL/行溢出.webp" style="zoom:67%;" />

上图展示的是`Compact`行格式在发生行溢出后的处理，`Compressed`和`Dynamic`这两个行格式和Compact非常类似，**主要的区别在于行处理溢出数据时有些区别**，这两种格式采用的是完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储20个字节的指针来指向溢出页，而实际的数据都存储在溢出页中，如下：

<img src="../../image/MySQL/行溢出2.webp" style="zoom:67%;" />



## MySQL操作命令

### 数据库操作

```mysql
# 查看全部数据库
SHOW DATABASES;
# 使用某个数据库
use database_name;
# 查看当前数据库
SELECT DATABASE();

# 创建库
CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项
	数据库选项：
		CHARACTER SET charset_name         # 设置数据库的字符集
		COLLATE collate_name               # 对于字符类型的列排序需要用到这个字段
```

[MYSQL中的COLLATE(COLLATION)是什么？_云骥行空的博客-CSDN博客_collation](https://blog.csdn.net/weixin_44167712/article/details/89883888)

```mysql
# 查看某个库的信息
SHOW CREATE DATABASE 数据库名
# 修改库的选项信息
ALTER DATABASE 库名 选项信息
# 删除库
DROP DATABASE [IF EXISTS] 数据库名  # 同时删除该数据库的相关的目录及其目录内容
```



### 表的操作

```mysql
# 创建表
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [库名.]表名 (表的结构定义) [表选项]
		每个字段必须都有数据类型
		最后一个字段后不能有逗号
		TEMPORARY表示临时表，会话结束后自动消失
		对于字段的定义
			字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']
	
    	表选项
    		字符集 CHARSET = charset_name，如果表没有设定，则使用数据库字符集
    		存储引擎 ENGINE = engine_name
    		        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        			常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
                    不同的引擎在保存表的结构和数据时采用不同的方式
                    MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
                    InnoDB表文件含义：.frm表定义，表空间数据和日志文件
                    SHOW ENGINES -- 显示存储引擎的状态信息
                    SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
             自增起始数  AUTO_INCREMENT = 行数
             数据文件目录 DATA DIRECTORY = '目录'
             索引文件目录 INDEX DIRECTORY = '目录'
             表注释 COMMENT ='string'
             分区选项 PARTITION BY...
        
        查看所有表，不可以直接使用下面命令
            mysql> show tables;
            ERROR 1046 (3D000): No database selected  # 很明显，要先use database;
            查看所有表 show tables [like 'pattern'];
            SHOW TABLES FROM DATABASE_NAME
		
		查看表结构
			SHOW CREATE TABLE 表名
			
		修改表
        	修改表本身的选项 ALTER TABLE 表名 [表的选项]
        	eg: ALTER TABLE 表名 ENGINE=MYISAM;
        
        	对表进行重命名
        		RENAME TABLE 原表名 TO 新表名
        		RENAME TABLE 原表名 TO 库名.表名（可以将表移动到另一个数据库中）  # 没有实验成功
        		
        	修改表的字段结构（ALTER TABLE语法）
                ALTER TABLE 表名 操作名
                -- 操作名
                    ADD[COLUMN] 字段定义       -- 增加字段
                        AFTER 字段名          -- 表示增加在该字段名后面
                        FIRST               -- 表示增加在第一个
                    ADD PRIMARY KEY(字段名)   -- 创建主键
                    ADD UNIQUE [索引名] (字段名)-- 创建唯一索引
                    ADD INDEX [索引名] (字段名) -- 创建普通索引
                    DROP[ COLUMN] 字段名      -- 删除字段
                    MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
                    CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改
                    DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
                    DROP INDEX 索引名 -- 删除索引
                    DROP FOREIGN KEY 外键    -- 删除外键	
         
         删除表
         	DROP TABLE [IF EXISTS] 表名
         清空表
         	TRUNCATE [TABLE] 表名
         复制表结构
         	CREATE TABLE 表名 LIKE 要复制的表名
         复制表结构和数据
         	CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
         检查表是否有错误
         	CHECK TABLE tbl_name[, tbl_name, tbl_name, ...]
         优化表
         	OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
         修复表
         	REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
		 分析表
			ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
```



### 数据操作

```mysql
# 增
INSERT [INTO] 表名 ([字段列表]) VALUES (值列表)[, (值列表), (值列表)...]
		-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
# 删
DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
# 改
UPDATE 表名 SET 字段名=新值[,字段名=新值][更新条件]
# 查
SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
```



### 字符集编码

```mysql
# MySQL、数据库、表、字段都可以设置字符集编码
SHOW VARIABLES LIKE 'character_set_%';   # 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results       服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码

SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES GBK;  -- 相当于完成以上三个设置

-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']   查看所有字符集
    SHOW COLLATION [LIKE 'pattern']     查看所有校对集
    CHARSET 字符集编码     设置字符集编码
    COLLATE 校对集编码     设置校对集编码
```



### 数据类型（列类型）

```mysql
1. 数值类型
-- a.整型 --
	类型			字节		范围（有符号位）
	tinyint	  	  1			-128~127	(无符号位)0~255
	smallint	  2			-32768~32767
	mediumint 	  3			-8388608 ~ 8388607
	int			  4
	bigint		  8
	int(M)  M表示总位数
     - 默认存在符号位，unsigned 属性修改
     - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
            例：int(5)   插入一个数'123'，补填后为'00123'
     - 在满足要求的情况下，越小越好。
    需要注意的是MySQL中是没有bool型的数据的，1表示bool值真，0表示bool值假。常用tinyint(1)表示布尔型。


-- b.浮点型 --
	类型			字节		范围（有符号位）
	float         4
	double		  8			
	浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)     double(M, D)
        M表示总位数，D表示小数位数。
        M和D的大小会决定浮点数的范围。不同于整型的固定范围。
        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。

-- c.定点数 --
	decimal  -- 可变长度
	decimal(M, D)   M也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每9位数字保存为4个字节。

2. 字符串类型
-- a. char  varchar --
	char		定长字符串，速度快，但是浪费时间
    varchar		非定长字符串，速度慢，但是节约空间
    M在这里表示的是最大长度，此长度是字符数，并非字节数
    不同的编码，所占用的空间不同。
    char,最多255个字符，与编码无关。
    varchar,最多65535个字符，与编码有关
    
    一条有效记录最大不能超过65535个字节
    utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2=65532字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3   # 因为使用utf-8一个汉字占三个字节
    
    
-- b. blob,text --
	blob		二进制字符串（字节字符串）
    text		非二进制字符串（字符字符串）
    text在定义的时候不可以给定默认值，也不需要定义长度，也不会计算总长度
    
-- c. binary, varbinary ----------
    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.
    
3. 日期时间类型
    一般用整型(bigint)保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3字节    日期         1000-01-01 到 9999-12-31
    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3字节    时间         -838:59:59 到 838:59:59
    year        1字节    年份         1901 - 2155
    
    datetime    YYYY-MM-DD hh:mm:ss
    timestamp   YY-MM-DD hh:mm:ss
                YYYYMMDDhhmmss
                YYMMDDhhmmss
                YYYYMMDDhhmmss
                YYMMDDhhmmss
    date        YYYY-MM-DD
                YY-MM-DD
                YYYYMMDD
                YYMMDD
                YYYYMMDD
                YYMMDD
    time        hh:mm:ss
                hhmmss
                hhmmss
    year        YYYY
                YY
                YYYY
                YY

4. 枚举和集合
-- 枚举(enum) --
enum(val1,val2,val3,...)
	在已知的值中进行单选，最大数量为65535
	枚举值在保存的时候，以2个字节的整型(smallint)保存，每个枚举值按照保存的文职顺序，从1开始逐渐递增
	表现为字符串类型，存储却是整型
	NULL值的索引是NULL
	空字符串错误值的索引是0
-- 集合(set) --
set(val1, val2, val3...)
    create table tab ( gender set('男', '女', '无') );  
    # 这里再创建表的时候必须指定字符集，不然中午没法解析，会爆出ERROR 1291 (HY000): Column 'gender' has duplicated value '?' in SET的错误，因此上面的sql语句是通过不了的，需要在后面加上charset=utf8
    insert into tab values ('男, 女');
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。
    注意：这种情况是可以成功的：
    mysql> insert into testSet values(2,'男,女');
	Query OK, 1 row affected (0.00 sec)
```



### 列属性（列约束）

```mysql
1. PRIMARY KEY 主键
	- 能唯一标识记录的字段，可以作为主键
	- 一个表只能够有一个主键，主键字段的值不能为空，而且主键具有唯一性
	- 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键可以由多个字段共同组成，此时需要在字段列表后声明
    	例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));
2. UNIQUE KEY 唯一索引，唯一索引字段的值不能重复
3. NULL 约束
	null不是数据类型，是列的一个属性。
    表示当前列是否可以为null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, 'val');
        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null
4. DEFAULT 默认属性值
	当前字段的默认值
5. AUTO INCREMENT 自动增长约束
	自动增长必须为索引（主键索引或者唯一索引）
	只能存在一个字段自动增长
	默认从1开始自动增长，可以通过表属性auto_increment=x进行设置，或者alter table tbl auto_increment=x;
6. COMMENT 注释
	例：create table tab ( id int ) comment '注释内容';
7.FOREIGN KEY 外键约束
	用于限制主表和从表的数据完整性
	ALTER TABLE T1 ADD CONSTRAINT `t1_t2_fk` foreign key(t1.id) references t2(id)
	将表t1的t1_id外键关联到表2的id字段
	每个外键都有一个名字，可以通过constraint来指定
	存在外键的表。称之为从表（子表），外键指向的表称之为主表（父表）
	作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。
    MySQL中，可以对InnoDB引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。
    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
    3. restrict，拒绝父表删除和更新。
    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。
```



### 建表规范

```mysql
/* 建表规范 */ ------------------
    -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除复合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。
```



### ==SELECT== 

```mysql
SELECT [ALL|DISTINCT] select_expr FROM -> WHERE -> GROUP BY [合计函数] -> HAVING -> ORDER BY -> LIMIT
-- a. select_expr --
	- 可以用*来表示全部字段
	- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
		select stu, 29+25, now() from tb;
	- 可以为每个列使用别名，适用于简化列标识，避免多个列标识重复
		可以使用关键字as，也可以不使用，比如select stu+10 as add10 from tb;
-- b. FROM --
	用于表示查询来源
	- 可以为表起别名，使用as关键字
		SELECT * FROM tb1 AS tt, tb2 AS bb;
	- from字句后，可以有多个表名
		多个表会横向叠加到一起，数据会形成一个笛卡尔积
	- 向优化符提示如何选择索引  # 没明白啥意思
        USE INDEX、IGNORE INDEX、FORCE INDEX
        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;
        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;	

--c. WHERE --
	从from获得的数据源中进行筛选
	整型1表示真，0表示假
	表达式由运算符和运算数组成
	-- 运算数：变量（字段）、值、函数返回值
    -- 运算符：
            =, <=>, <>, !=, <=, <, >=, >, !, &&, ||,
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上ture/false/unknown，检验某个值的真假
            <=>与<>功能相同，<=>可用于null比较
            
--d. GROUP BY 子句，分组子句--
	GROUP BY 字段/别名 [排序方式]
	分组后会进行排序，升序AES，降序DESC
	以下合计函数需要配合GROUP BY使用
		count返回不同的非NULL值数目 count(*)，count(字段)
		sum 求和
		avg 求平均值
		max 求最大值
		min 求最小值
		group_concat  返回带有来自一个组的连接的非NULL值的字符串结果，组内字符串连接

--e. HAVING --
	与WHERE功能，用法相同，执行时机不同
	WHERE在开始执行时检测数据，对原数据进行过滤
	having对过滤出来的数据再次进行过滤
	having字段必须是查询出来的，而where字段必须是数据表中存在的
	where不可以使用字段的别名，having可以，因为在where执行的时候还没有确定列值
	where不可以使用合计函数，一般需要合计函数才会用having
	SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列

-- f. ORDER BY 子句，排序子句 --
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。

-- g. LIMIT 子句，限制结果数量子句 --
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引0开始。limit 获取条数
-- h. DISTINCT , ALL --
	DISTINCT 去除重复记录
	默认为all，全部记录
```



### UNION

```mysql
/* UNION */ ------------------
    将多个select查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个SELECT查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各select查询的字段数量一样。
    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。
```



### 子查询

```mysql
/* 子查询需要用括号包裹 */
-- from型
	from后要求是一个表，必须给子查询结果取个别名
	- 简化每个查询内的条件
	- from型需要将结果生成一个临时表，可用以原表的锁定的释放（没明白）
	- 子查询返回一个表，表型子查询
	select * from (select * from tb where id > 0) as subfrom where id > 1;

-- where型
	子查询返回一个值，标量子查询
	不需要给子查询取别名
	where子查询内的表，不能直接用以更新
	select * from tb where money = (select max(money) from tb);
		-- 列子查询
			如果子查询返回的结果是一列，使用in或者not in完成查询
        	exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
   		 -- 行子查询
            查询条件是一个行。
        	select * from t1 where (id, gender) in (select id, gender from t2);
        	行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        	行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。
    	-- 特殊运算符
            != all()    相当于 not in
            = some()    相当于 in。any 是 some 的别名
            != some()   不等同于 not in，不等于其中某一个。
            all, some 可以配合其他运算符一起使用。
```



### 连接查询（join）

```mysql
/* 连接查询(join) */ ------------------
    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
    也可用where表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)
    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)，查询条件只能使用on，不能使用where和using
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为null填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join
select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;
```



### truncate

```mysql
/* TRUNCATE */ ------------------
TRUNCATE [TABLE] tbl_name
清空数据
删除重建表
区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区
```



### 备份与还原

```mysql
/* 备份与还原 */ ------------------
备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。
-- 导出
mysqldump [options] db_name [tables]
mysqldump [options] ---database DB1 [DB2 DB3...]
mysqldump [options] --all--database
1. 导出一张表
　　mysqldump -u用户名 -p密码 库名 表名 > 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 > 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u用户名 -p密码 库名 > 文件名(D:/a.sql)
4. 导出一个库
　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 > 文件名(D:/a.sql)
可以-w携带WHERE条件
-- 导入
1. 在登录mysql的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u用户名 -p密码 库名 < 备份文件
```



### 视图

> 什么是视图？

视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包含一系列带有名称的列和行数据，但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。

视图具有表结构文件，但是不存在数据文件

对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
视图是存储在数据库中的查询的`sql`语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

```mysql
# 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过ALGORITHM指定。
    - column_list如果存在，则数目必须等于SELECT语句检索的列数

查看视图结构
	- show create view view_name;
删除视图
	- 删除视图后，数据依然存在
	- 可同时删除多个视图
	DROP VIEW [IF EXISTS] view_name...
修改视图结构
    一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement
视图作用
	1. 简化业务逻辑
	2. 对客户端隐藏真实的表结构
视图算法(ALGORITHM)
    MERGE       合并
        将视图的查询语句，与外部查询需要先合并再执行！（视图中更新的数据会更新到数据库表中）
    TEMPTABLE   临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。	
```



### 事务

事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。

- 支持连续SQL的集体成功或集体撤销。
- 事务是数据库在数据完整性方面的一个功能。
- 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
- InnoDB被称为事务安全型引擎。

```mysql
事务开启
	START TRANSACTION;或者 BEGIN;
	开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句
事务提交
	COMMIT;
事务回滚
	ROLLBACK;
	如果部分操作发生错误，映射到事务开始前
事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。  

事务的实现
	1.要求是事务支持的表类型
	2.执行一组相关操作前开启事务
	3.整组操作完成后，都成功则提交，如果存在失败，选择回滚，则会回到事务开始前的备份点
事务的原理
	利用InnoDB的自动提交（autocommit）特性完成
	普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见
	而事务是暂时关闭的“自动提交”机制，需要commit提交持久化数据操作
注意
	1.数据定义语言（DDL）语句不能被回滚，比如创建或者取消数据库的语句，和创建、取消或更改表或存储的子程序的语句
	2.事务不能被嵌套
保存点
	SAVEPOINT 保存点名称        ---- 设置一个事务保存点
	ROLLBACK TO SAVEPOINT 保存点名称  ---- 回滚到保存点
	RELEASE SAVEPOINT 保存点名称   ---- 删除保存点
	
InnoDB自动提交特性设置
    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与 START TRANSACTION不同的是，
        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而 START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)	
```



### 锁表

```mysql
/* 锁表 */
表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES
```



### 触发器

触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象

监听：记录的增加、修改、删除

```mysql
# 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
	参数：
		trigger_time 是触发程序的动作时间，它可以使 before 或者 after，以指明触发程序是在激活它的语句之前或者之后触发
		trigger_enent 指明了激活触发程序的语句的类型
			INSERT 将新行插入表时激活触发程序
			UPDATE 更改某一行时激活触发程序
			DELETE 从表中删除某一行时激活触发程序
		tbl_name 监听的表，必须是永久性的表，不能将触发器和视图或者临时表关联起来
        trigger_stmt 当触发程序激活时执行的语句，执行多个语句，可以使用 BEGIN ... END 复合语句结构
      
# 删除触发器
DROP TRIGGER [schema_name.] trigger_name
	可以使用old和new替代旧的和新的数据
	更新操作，更新前是old，更新后是new
	删除操作，只有old
	增加操作，只有new

# 注意：对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。

# 字符连接函数
concat(str1, str2, ...)
concat_ws(separator, str1, str2,...)

# 分支语句
if 条件 then
	执行语句
elseif 条件 then
	执行语句
else 
	执行条件
end if;

# 修改最外层语句结束符
delimiter 自定义结束符号
	 SQL语句
   自定义结束符号
   delimiter ;     -- 修改回原来的分号

# 语句块包裹
begin 
	语句块
end

# 特殊的执行
1.只要添加记录，就会触发程序
2.Insert into on duplicate key update
	如果没有重复记录，会触发 before insert, after insert
	如果有重复记录并更新，会触发 before insert, before update, after update
	如果有重复记录但是没有发生更新，则触发 before insert, before update
3.Replace语句
	如果有记录，则执行 before insert, before delete, after delete, after insert
```



### SQL编程

```mysql
-- 局部变量 --
    # 变量声明
        declare var_name[,...] type [default value]
        这个语句被用来声明局部变量，要给变量提供一个默认值，请包含一个default子句，值可以被指定为一个表达式，不需要为一个常数，如果没有 default 子句，初始值为null

    # 赋值
        使用 set 和 select into 语句为变量赋值
        注意，在函数内是可以使用全局变量的（用户自定义的变量）
	
-- 全局变量 --
	# 定义、赋值
	set语句可以定义并且赋值变量
	set @val=value;
	也可以使用 select into 语句为变量初始化并赋值，这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致，还可以把赋值语句看作一个表达式，通过select 执行完成，此时为了避免=被当作关系运算符看待，使用:=代替（set中可以使用=或者:=）
	select @var := 20;
	select @v1 := id, @v2=name from t1 limit 1;
	select * from tbl_name where @var := 30
	select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;

-- 自定义变量 --
	为了避免 select 语句中，用户自定义的变量与系统标识符（通常是字段名冲突），用户自定义变量在变量名前使用@作为开始符号
	@var=10; # 变量被定义之后，在整个会话周期都有效（登录到退出）
	
-- 控制结构 --
	if 语句
	if search_condition then statement_list
	[elseif search_condition then 
    	statement_list]
    ...
    [else 
    	statement_list]
    end if;

-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END

-- while循环 --
[begin_label:] while search_condition do
    statement_list
end while [end_label];
- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。
    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环
        
-- 内置函数 --
	# 数值函数
		abs(x)  		绝对值 abs(-10.9) = 10
		format(x, d)    格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
		ceil(x)			向上取整	ceil(10.1) = 11
		floor(x)		向下取整  	floor(10.1) = 10
		round(x)		四舍五入取整
		mod(m, n)		m%n	m mod n 取余 10 % 3 = 1
		pi()			获得圆周率
		pow(m, n)		m ^ n
		sqrt(x)			算术平方根
		rand()			随机数
		truncate(x, d)	截取d位小数
		
	# 时间日期函数
    	now(), current_timestamp()		获得当前日期时间
    	current_date()					获得当前日期
    	current_time()					获得当前时间
    	date('yyyy-mm-dd hh:ii:ss');    -- 获取日期部分
        time('yyyy-mm-dd hh:ii:ss');    -- 获取时间部分
        date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间
        unix_timestamp();               -- 获得unix时间戳
        from_unixtime();                -- 从时间戳获得时间
    # 字符串函数
        length(string)          -- string长度，字节
        char_length(string)     -- string的字符个数
        substring(str, position [,length])      -- 从str的position开始,取length个字符
        replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str
        instr(string ,substring)    -- 返回substring首次在string中出现的位置
        concat(string [,...])   -- 连接字串
        charset(str)            -- 返回字串字符集
        lcase(string)           -- 转换成小写
        left(string, length)    -- 从string2中的左边起取length个字符
        load_file(file_name)    -- 从文件读取内容
        locate(substring, string [,start_position]) -- 同instr,但可指定开始位置
        lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length
        ltrim(string)           -- 去除前端空格
        repeat(string, count)   -- 重复count次
        rpad(string, length, pad)   -- 在str后用pad补充,直到长度为length
        rtrim(string)           -- 去除后端空格
        strcmp(string1 ,string2)    -- 逐字符比较两字串大小
      # 流程函数
        case when [condition] then result [when [condition] then result ...] [else result] end   多分支
        if(expr1,expr2,expr3)  双分支。
	  # 聚合函数
        count()
        sum();
        max();
        min();
        avg();
        group_concat()
	  # 其他常用函数
        md5();
        default();
        
--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体
    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由"参数名"和"参数类型"组成。多个参数用逗号隔开。
    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。
-- 删除
    DROP FUNCTION [IF EXISTS] function_name;
-- 查看
    SHOW FUNCTION STATUS LIKE 'partten'
    SHOW CREATE FUNCTION function_name;
-- 修改
    ALTER FUNCTION function_name 函数选项
--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。
-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体
参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型
注意，没有返回值。    
```



### 存储过程

```mysql
/* 存储过程 */ ------------------
存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中
-- 参数
IN|OUT|INOUT 参数名 数据类型
IN      输入：在调用过程中，将数据输入到过程体内部的参数
OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT   输入输出：既可输入，也可输出
-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END
```



### 用户和权限管理

```mysql
/* 用户和权限管理 */ ------------------
-- root密码重置
1. 停止MySQL服务
2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &
    [Windows] mysqld --skip-grant-tables
3. use mysql;
4. UPDATE `user` SET PASSWORD=PASSWORD("密码") WHERE `user` = "root";
5. FLUSH PRIVILEGES;
用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES;
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 'user_name'@'192.168.1.1'
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD('密码')  -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password']
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
    GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817';
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER   -- 允许使用ALTER TABLE
ALTER ROUTINE   -- 更改或取消已存储的子程序
CREATE  -- 允许使用CREATE TABLE
CREATE ROUTINE  -- 创建已存储的子程序
CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE
CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW     -- 允许使用CREATE VIEW
DELETE  -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE     -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX   -- 允许使用CREATE INDEX和DROP INDEX
INSERT  -- 允许使用INSERT
LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES  -- 未被实施
RELOAD  -- 允许使用FLUSH
REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT  -- 允许使用SELECT
SHOW DATABASES  -- 显示所有数据库
SHOW VIEW   -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE  -- 允许使用UPDATE
USAGE   -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限
```



### 表维护

```mysql
/* 表维护 */
-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
```



### 杂项

```mysql
/* 杂项 */ ------------------
1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _   任意单个字符
    %   任意多个字符，甚至包括零字符
    单引号需要进行转义 \'
5. CMD命令行内的语句结束符可以为 ";", "\G", "\g"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：\c
```

















