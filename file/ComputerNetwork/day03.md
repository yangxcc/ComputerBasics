## HTTP协议还可以从哪些方面进行优化

前面我复习过了HTTP/1.1对于HTTP/1.0的优化是使用了长连接和管道网络传输，这样能够减少TCP连接创建和断开导致的时间开销，但是会出现队头阻塞、头部信息冗余等问题；HTTP/2对于HTTP/1.1的优化是使用了多路复用机制、二进制帧、数据流、头部压缩算法来解决了上述的问题，但是因为HTTP/2的底层是TCP，所以一旦发生丢包现象，这一个TCP连接里面的请求都会被阻塞，知道丢失的包被重传回来，所以HTTP/3对于HTTP/2的优化就在于将底层TCP更换成了UDP，实现了一个QUIC协议，这个协议能够实现稳定传输，换句话说，QUIC是一个基于UDP的伪TCP协议

除了上面这些，从哪些方面还可以对HTTP协议进行优化呢？

### 避免发送HTTP请求

怎么能够避免发送HTTP请求呢？答案是通过**缓存**，对于一些重复的HTTP请求，其响应是一样的，那么我们可以把`请求-响应`看作是`key-value`缓存到本地，当发送HTTP请求之前，现在本地缓存中查找一下，如果能够找到，那么就不用再发送请求了

<img src="../../image/ComputerNetwork/image-20211112144911496.png" alt="image-20211112144911496" style="zoom:80%;" />

但是上面的缓存存在一个问题：如果服务器上的资源发生了变化，而请求并没有到达服务器，这样就会造成请求的数据和服务器上现在的数据不一致，那么怎么解决这个问题的？答案是给响应设置一个**过期时间**，具体流程为：

- 第一次的请求会被发送到服务端，服务端会在响应数据的头部设置一个字段叫做过期时间，这个过期时间是服务器计算出来的，预估的一个数值，然后客户端会把这个响应数据缓存起来
- 当客户端再次发送相同的请求时，回先查看自己本地的缓存中数据头部的过期时间
  - 如果没有超过过期时间，那么客户端不用在向服务器发送请求，直接使用缓存中的数据就好了
  - 如果超过了过期时间，那么客户端需要向服务端再次发送请求，在请求的头部带上本地缓存中响应数据的摘要，这个摘要是本地缓存中数据的唯一标识，服务端收到请求之后，会把自己将要发送的数据和本地缓存中的数据进行比较，如果没有发生变化，那么返回的响应数据中可以没有body，状态码为204，而如果发生了变化，则返回的响应中需要携带上最新的数据

<img src="../../image/ComputerNetwork/image-20211112150117208.png" alt="image-20211112150117208" style="zoom:80%;" />





### 减少发送HTTP请求的次数

#### 减少重定向的次数

服务器上的资源可能由于维护、迁移等原因由url1变成了url2，但是客户端并不知道这种改动，而当客户端通过url1访问时，服务端不能够仅仅简单地返回404，而是应该返回302（临时重定向）和Location头部，告诉客户端服务器的资源已经迁移至url2，于是客户端需要向url2发送请求以获得服务器资源，如下图：

<img src="../../image/ComputerNetwork/image-20211112151109064.png" alt="image-20211112151109064" style="zoom:50%;" />

而且客户端和服务端之间往往不是直接相连，中间会存在一台或者多台代理服务器，因此重定向的次数越多，客户端发送的请求次数就越多，越会加重网络的负担

如果代理服务器能够完成重定向的工作，就可以减少HTTP重定向的请求次数了

<img src="../../image/ComputerNetwork/image-20211112151629995.png" alt="image-20211112151629995" style="zoom:50%;" />

如果代理服务器知道了重定向的规则，那么就能够进一步减少重定向的请求次数了

<img src="../../image/ComputerNetwork/image-20211112151716014.png" alt="image-20211112151716014" style="zoom:50%;" />

如果在重定向过程中返回的是301状态码，那么客户端可以想重定向的结果缓存到本地，以后直接通过发送url2就可以了



#### 合并请求

把多个小请求合并成一个大请求，虽然传输的总资源没有发生变化，但是将多个小请求合并成一个大请求，会**减少发送重复的请求头部**

另外，如果是HTTP/1.1，因为他是请求-响应模式，如果一个请求迟迟未得到响应，那么后面的请求就发不出去（队头阻塞），所以在HTTP/1.1中，为了防止单个请求的阻塞，浏览器一般会同时发送`5~6`个请求，每一个请求都是不同的TCP连接，那么如果合并了请求，也就是会减少TCP连接的数量，也较少了TCO连接握手和慢启动过程的耗时

**合并请求的方式就是合并资源，以一个大资源的请求代替多个小资源的请求，但是这样的合并请求会带来新的问题，如果大资源中的小资源发生了变化，客户端必须重新下载整个的大资源**



#### 延迟发送请求

 ⼀般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来， 于是可以通过 **「按需获取」**的方式，来减少第⼀时间的HTTP 请求次数。 请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。



### 压缩响应数据的大小

这里特指的HTTP/1.1，因为HTTP/2中有头部压缩算法，而且无论是头部还是数据部分，都被转化成了二进制帧，所以也没有太大压缩的必要，而HTTP/1.1中是没有办法对头部进行压缩的，静态表、动态表、Huffman编码是HTTP/2的内容，所以他可以对响应数据的body进行压缩

压缩方式主要分成了有损压缩和无损压缩

- 无损压缩主要是用在压缩程序源代码、可执行文件、文本文件等
- 有损压缩主要用在视频、图片等，他的压缩效果更好，但是会降低源文件的质量





## HTTPS的解析过程

在`day01.md`中就已经说到了HTTPS相较于HTTP就是多了一层`SSL/TLS`层，如下图

<img src="../../image/ComputerNetwork/image-20211112155105315.png" alt="image-20211112155105315" style="zoom:50%;" />

HTTPS就是通过`SSL/TLS`这一层解决了HTTP中存在的三个问题：窃听风险、假冒风险、篡改风险，而且HTTP在TCP三次握手之后就能够开始进行明文通信了，而HTTPS需要在TCP三次握手之后，在等`SSL/TLS`握手之后才能够进行加密通信

### SSL/TLS握手过程（以RSA密钥交换算法为例）

接下来，来看一下`SSL/TLS`的握手过程

![image-20211112195544822](../../image/ComputerNetwork/image-20211112195544822.png)

上图简要概述了TLS握手的过程，每一个框都表示一条记录（record），类似于TCP中的`segment`，**记录是TLS收发数据的基本单位**，多个记录可以组成一个TCP包发送，所以通常需要经过四次TLS握手，2个RTT的时延，然后就能够在安全的通信环境里面进行加密通信了

**事实上，不同的密钥交换算法，TLS握手过程可能会有一些不同**

TLS中的密钥交换算法，考虑到加密通信的性能问题，在加密过程中通过对称加密算法，而对称加密算法的密钥是不能够被泄露的，因此为了保证密钥的安全性，使用非对称加密算法对密钥进行保护，这个工作就是由密钥交换算法来完成的

TLS握手的具体过程

- **<font color=red>第一次握手</font>**

  客户端发送`ClientHello`，具体包含TLS版本，客户端能够支持的密码套件列表以及客户端产生的一个随机数`Client-Random`，将这些信息发送到服务器，上面的这个随机数将会被服务端保留，用于后面的会话密钥制作

  ![image-20211112200821423](../../image/ComputerNetwork/image-20211112200821423.png)

- **<font color=red>第二次握手</font>**

  第二次握手的过程比较多，可以分为`ServerHello`，`Certificate`，`ServerKeyExchange`，`ServerHelloDone`四个子流程

  - 首先是`ServerHello`，这一个过程中服务器会根据客户端发送过来的信息进行处理，首先确认TLS的版本，看看自己是否支持，然后他也会产生一个随机数`Server-Random`，最后他会在客户端支持的密码套件列表中选择出一个密码套件用于后续工作

    <img src="../../image/ComputerNetwork/image-20211112201209917.png" alt="image-20211112201209917" style="zoom:67%;" />

    ```shell
    # 密码套件的格式
    # 密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法
    # 比如上面的TLS_RSA_WITH_AES_128_GCM_SHA256
    # 密钥交换算法和签名算法都是RSA（with前面的两个算法分别是密钥交换算法和签名算法）
    # TLS握手成功之后，通过AES对称加密来加密通信，密钥长度为128，分组模式为GCM
    # 摘要算法使用SHA256用于消息生产和产生随机数
    ```

    

  - 然后是`Certificate`，服务器将上述信息整合成一个记录，随后服务器为了证明自己的身份会将自己的数字证书整合成一个记录

    ![image-20211112201443366](../../image/ComputerNetwork/image-20211112201443366.png)

    > 当服务器将数字证书发送过去之后，客户端是怎样验证的呢？

    首先，数字证书中包含很多信息，比如公钥、持有者信息，证书认证机构的信息等，数字证书的作用就是用来验证公钥持有者的身份，以防止第三方冒充，在这里面就是用来让客户端验证服务器是否可信

    <img src="../../image/ComputerNetwork/image-20211112202214144.png" alt="image-20211112202214144" style="zoom:80%;" />

    ```shell
    # 证书签名的过程如上图中的左图
    
    # 1.首先CA会把持有者公钥、用途、颁发者、有效时间等信息打成一个包，然后对这个包进行HASH计算，得到一个hash值
    # 2.然后用CA的私钥对这个hash值进行加密，生成Certificate Signature（数字签名）
    # 3.最后将数字签名添加到文件证书上，形成数字证书
    
    # 客户端骄校验数字证书的过程如上图中的右图
    
    # 1.客户端会使用相同的hash算法对持有者信息、证书认证机构等信息进行一次计算
    # 2.客户端使用CA公钥对数字证书中的数字签名进行解密
    # 3.比较解密出来的数字签名和第一步中的计算出来的hash值，如果相同证明服务器可信，如果不同，那么服务器不可信
    ```

  

  - 随后，服务器会发送`ServerHelloDone`，表示服务器将应该发送给客户端的数据都发送过去了，第二次握手结束

  **可以看出，当TLS第一次和第二次握手结束之后，客户端和服务端确定了TLS的版本，并且都知道了后续应该使用什么密码套件来进行工作，而且都有了两个随机数**

- **<font color=red>第三次握手</font>**

  第三次握手发生在客户端校验完成服务器数字证书之后，紧接着客户端会产生另外一个新的随机数，叫做`pre-master`，接着用服务器的RSA公钥加密这个随机数，通过`Client Key Exchange`这条记录将这个随机数发送给服务端

  ![image-20211112204038544](../../image/ComputerNetwork/image-20211112204038544.png)

  服务器收到之后，会使用RSA私钥解密这个随机数

  **三次握手成功之后，客户端和服务端双方都拥有了三个随机数，分别是Client-Random,Server-Random,pre-master，于是双方会根据这三个随机数生成<font color=red>会话密钥（Master Secret）</font>，他是对称密钥，用于后续的加密通信**

  生成完会话密钥之后，客户端又会产生一个记录，名为`change Ciper Spec`，通知服务端后续将使用上面的会话密钥进行通信了

  <img src="../../image/ComputerNetwork/image-20211112204946130.png" alt="image-20211112204946130" style="zoom:67%;" />

  最后客户端会把之前发过去的全部信息做个摘要，在使用会话密钥加密一下，让服务器做个验证，看看在上面过程中是否发生了篡改，上面的这个摘要会被放到`Encrypted Handshake Message`这个纪录中

  <img src="../../image/ComputerNetwork/image-20211112205125584.png" alt="image-20211112205125584" style="zoom:67%;" />

- **<font color=red>第四次握手</font>**

  服务器收到第三次握手的消息后，也会先生成会话密钥，然后生成`Change Cipher Spec`记录，然后再去验证客户端发送过来的摘要，将验证结果放入`Encrupted Handshake Message`，如果客户端和服务端双方加密和解密都没有问题，那么握手正式完成，之后便会通过上面产生的会话密钥（Master Secret）进行加密通信了



### 不同密钥交换算法的比较

上面我描述的TLS握手过程是使用RSA作为密钥交换算法的，但是RSA不具备前向安全性，也就是说当服务器上的RSA私钥被泄露之后，会话密钥（Master Secret）就会被攻击者获得，然后客户端和服务器之间的全部的加密通信信息都会被其破解

为了解决上述问题就有了DH密钥交换算法，流程如下：

<img src="../../image/ComputerNetwork/image-20211113094745271.png" alt="image-20211113094745271" style="zoom:67%;" />

DH算法中密钥的交换方式如下

```
先假设小红和小明约定使用DH算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这个参数是公开的，用P和G来代表
```

然后小红和小明各自生成一个随机数作为私钥，双方的私钥需要保密管理，不能够泄露，小红的私钥用a代称，小明的私钥用b代称，然后小红和小明双方都有了`P,G,以及各自的私钥`，于是就可以计算出公钥

- 小红的公钥记为A，$A=G^a(mod \quad p)$
- 小明的公钥记为B，$B=G^b(mod \quad p)$

A和B也是公开的，因为根据离散对数的原理，从真数AB反向计算对数ab是十分困难的，至少在现有计算机水平上是破解不出来的

双方交换各自的DH公钥后，手上都分别有五个参数：`P,G,A,B,以及各自的私钥`，然后小红和小明可以分别进行计算

- 小红执行运算 $B^a(mod \quad p)$，其结果为`K`
- 小明执行运算$A^b(mod \quad p)$，因为离散对数的幂运算有交换律，所以其结果也是为`K`

**这个`K`就是小红与小明之间通信的对称加密密钥，可以作为会话密钥使用**

可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而a、b 是双⽅各⾃保管的私钥，⿊客无法获取这 2 个私钥，因此⿊客只能从公开的 P、G、A、B 入手， 计算出离散对数（私钥）。
前面也多次强调， 根据离散对数的原理，如果 P 是⼀大数，在现有的计算机的计算能力是很难破解出私钥 a、b的，破解不出私钥，也就⽆法计算出会话密钥，因此 DH 密钥交换是安全的。



事实上，根据私钥胜场的方式，DH算法又可以分成两种

- static DH算法，现在已经被废弃
- DHE算法，目前常用

在static DH算法中固定了一方的私钥，通常保持不变的是服务器的私钥，这种情况下，随着时间的延长，黑客可能会获得大量的加密数据，因为在DH算法中，公钥等一些参数是公开的，所以黑客可能会通过暴力破解的方式得到服务器的私钥，得到服务器的私钥之后，就能够知道会话密钥了，之前截获的加密通信就都能够被破解出来了，所以**static DH算法也是不具有前向安全性的**

而后面的DHE算法，其中的E表示的就是ephemeral（临时性的），既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。

所以，即使有个黑客破解了某⼀次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」。



从上面的过程中，可以看出，DHE算法虽然能够保证前向安全性，但是在计算过程中有大量的乘法运算，也就是说它的效率不佳，所以为了提高效率，后面又提出了ECDHE算法，这个算法在现在也是被广泛使用，**ECDHE算法就是在DHE算法的基础上利用椭圆曲线用更少的计算量算出公钥，提高效率**



使用ECDHE算法的握手过程

- **第一次握手：**和RSA算法一样，第一次握手还是`Client Hello`，向服务器发送自己的TLS版本，生成的一个随机数（client-random）以及支持的密码套件列表

  <img src="../../image/ComputerNetwork/image-20211113100849575.png" alt="image-20211113100849575" style="zoom:60%;" />

  

- **第二次握手：**这此握手中，会比RSA中多出一个`Server key Exchange`

  - 服务器收到客户端的 Client Hello 之后需要进行回复，返回 Server Hello 消 息，消息里面有服务器确认的TLS版本，也会随即给出一个随机数（Server Random），然后从客户端的密码套件列表中选择一个合适的密码套件

    <img src="../../image/ComputerNetwork/image-20211113101059953.png" alt="image-20211113101059953" style="zoom:60%;" />

  - 接着服务器端为了证明自己的身份，发送`certificate`消息，会把证书也发给客户端

    <img src="../../image/ComputerNetwork/image-20211113101219780.png" alt="image-20211113101219780" style="zoom:67%;" />

  - 如果是在RSA中，接下来就是发送`Server Hello Done`了，但是使用EDCHE密钥交换算法，**在`Server Hello Done`前面还有一步就是`Server Key Exchange`，这个过程服务器做了三件事情**

    - 第一件事情：选择了名为`named_curve`的椭圆曲线，选择好了椭圆曲线相当于椭圆曲线基点 G 也定好了（在ECDHE中就是根据这个基点算出私钥对应的公钥），这些都会公开给客户端
    - 第二件事情：生成一个随机数作为服务器端的椭圆曲线的私钥，保存在服务器本地
    - 第三件事情：根据上面的椭圆曲线和基点G算出私钥对应的公钥，将这个公钥发送给客户端

    <img src="../../image/ComputerNetwork/image-20211113101451857.png" alt="image-20211113101451857" style="zoom:67%;" />

    同时，为了保证发送给客户端的公钥不被篡改，ECDHE算法中还使用了RSA算法对其进行加密，以便进行完整性校验

    至此，使用ECDHE密钥协商算法的第二次握手就结束了，服务器发送`Server Hello Done`，表示自己想要发送的数据都给客户端了，打招呼完毕

    <img src="../../image/ComputerNetwork/image-20211113102159051.png" alt="image-20211113102159051" style="zoom:67%;" />

    

  **可以发现，第二次握手结束之后，客户端和服务端双方共享了一些数据，包括：client-random，server-random，还有服务端椭圆曲线的公钥，使用的椭圆曲线以及基点G**，其实和RSA大同小异，因为使用RSA在第二次握手结束之后，双方共享的client-random,server-random，以及后续生成对称密钥要使用的算法

- **第三次握手：**客户端收到了服务端的证书后，自然是要先校验证书是否合法，如果证书合法，那么 服务端到身份就是没问题的。校验 证书到过程，会走证书链逐级验证，确认证书的真实性，再⽤证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。

  随后，客户端会产生一个随机数来作为自己的私钥，然后通过选出来的椭圆曲线和基点G计算出一个公钥，把这个公钥发送给服务器，这一部分叫做`Client key Exchange`

  <img src="../../image/ComputerNetwork/image-20211113103700290.png" alt="image-20211113103700290" style="zoom:67%;" />

  ```shell
  # 至此，客户端和服务器共享的数据有：client-random,server-random,分别使用椭圆曲线计算出来的公钥，椭圆曲线，基点G，于是双方会根据`对方的椭圆曲线公钥 + 自己的椭圆曲线私钥 + 基点G`计算出一个密钥（记作x），在ECDHE算法原理中，计算出来的这个密钥就被作为最后的密钥了，但是在实际应用中，这个密钥并不会被作为最终的密钥，因为TLS设计者并不信任客户端和服务器端伪随机数的可靠性，所以最后的会话密钥是`client-random + server-random + x`，这样做虽然也保证不了完全的随机，但是三个伪随机数的组合，随机程度也就很高了
  ```

  算好会话密钥之后，客户端会向服务器发送`Change Cipher Spec`消息，告诉服务器后续会使用这个会话密钥进行通信了

  接着，客户端会发 「Encrypted Handshake Message」 消息，把之前发送的数据做⼀个摘要，再 用对称密钥加密 ⼀下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用

  <img src="../../image/ComputerNetwork/image-20211113104647134.png" alt="image-20211113104647134" style="zoom:67%;" />

- **TLS第四次握手，**最后服务端也会进行相同的操作 change ciper spec 和 encrypted handshake message 消息，如果双方都验证加密和解密没有问题，那么握手完成，于是就可以正常收发加密的 HTTP请求和响应了



综上，可以总结一下使用RSA和ECDHE密钥协商交换算法握手过程的不同之处

- RSA算法不支持前向安全性，而ECDHE算法具备前向安全性

- 使用ECDHE密钥协商算法，TLS第二次握手过程中会多一个`server key exchange`，表示把服务器椭圆曲线私钥发送给客户端

- 使用了RSA密钥协商算法，TLS完成四次握手之后才可以进行应用数据加密传输，而对于ECDHE算法，客户端可以不用等服务端最后一次TLS握手，就可以提前发出加密的HTTP数据，节省了一个消息的往返时间

  <img src="../../image/ComputerNetwork/image-20211113110911096.png" alt="image-20211113110911096" style="zoom:80%;" />

所以，ECDHE算法相对于RSA算法的握手过程省去了一个消息往返的时间，这个有点抢跑的意思，它被称作是`TLS FALSE START`，类似于`TCP FAST OPEN`，都是在连接还没有完全建立之前，就发送了应用数据，这样便提高了数据的传输效率













## END

